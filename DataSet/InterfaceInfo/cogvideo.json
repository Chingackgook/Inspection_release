{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/CogVideo",
    "API_Calls": [
        {
            "Name": "generate_video_cli_demo",
            "Description": "call generate_video to generate a video from a text prompt or an image/video input.",
            "Code": "\"\"\"\nThis script demonstrates how to generate a video using the CogVideoX model with the Hugging Face `diffusers` pipeline.\nThe script supports different types of video generation, including text-to-video (t2v), image-to-video (i2v),\nand video-to-video (v2v), depending on the input data and different weight.\n\n- text-to-video: THUDM/CogVideoX-5b, THUDM/CogVideoX-2b or THUDM/CogVideoX1.5-5b\n- video-to-video: THUDM/CogVideoX-5b, THUDM/CogVideoX-2b or THUDM/CogVideoX1.5-5b\n- image-to-video: THUDM/CogVideoX-5b-I2V or THUDM/CogVideoX1.5-5b-I2V\n\nRunning the Script:\nTo run the script, use the following command with appropriate arguments:\n\n```bash\n$ python cli_demo.py --prompt \"A girl riding a bike.\" --model_path THUDM/CogVideoX1.5-5b --generate_type \"t2v\"\n```\n\nYou can change `pipe.enable_sequential_cpu_offload()` to `pipe.enable_model_cpu_offload()` to speed up inference, but this will use more GPU memory\n\nAdditional options are available to specify the model path, guidance scale, number of inference steps, video generation type, and output paths.\n\n\"\"\"\n\nimport argparse\nimport logging\nfrom typing import Literal, Optional\n\nimport torch\n\nfrom diffusers import (\n    CogVideoXDPMScheduler,\n    CogVideoXImageToVideoPipeline,\n    CogVideoXPipeline,\n    CogVideoXVideoToVideoPipeline,\n)\nfrom diffusers.utils import export_to_video, load_image, load_video\n\n\nlogging.basicConfig(level=logging.INFO)\n\n# Recommended resolution for each model (width, height)\nRESOLUTION_MAP = {\n    # cogvideox1.5-*\n    \"cogvideox1.5-5b-i2v\": (768, 1360),\n    \"cogvideox1.5-5b\": (768, 1360),\n    # cogvideox-*\n    \"cogvideox-5b-i2v\": (480, 720),\n    \"cogvideox-5b\": (480, 720),\n    \"cogvideox-2b\": (480, 720),\n}\n\n\ndef generate_video(\n    prompt: str,\n    model_path: str,\n    lora_path: str = None,\n    lora_rank: int = 128,\n    num_frames: int = 81,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    output_path: str = \"./output.mp4\",\n    image_or_video_path: str = \"\",\n    num_inference_steps: int = 50,\n    guidance_scale: float = 6.0,\n    num_videos_per_prompt: int = 1,\n    dtype: torch.dtype = torch.bfloat16,\n    generate_type: str = Literal[\"t2v\", \"i2v\", \"v2v\"],  # i2v: image to video, v2v: video to video\n    seed: int = 42,\n    fps: int = 16,\n):\n    \"\"\"\n    Generates a video based on the given prompt and saves it to the specified path.\n\n    Parameters:\n    - prompt (str): The description of the video to be generated.\n    - model_path (str): The path of the pre-trained model to be used.\n    - lora_path (str): The path of the LoRA weights to be used.\n    - lora_rank (int): The rank of the LoRA weights.\n    - output_path (str): The path where the generated video will be saved.\n    - num_inference_steps (int): Number of steps for the inference process. More steps can result in better quality.\n    - num_frames (int): Number of frames to generate. CogVideoX1.0 generates 49 frames for 6 seconds at 8 fps, while CogVideoX1.5 produces either 81 or 161 frames, corresponding to 5 seconds or 10 seconds at 16 fps.\n    - width (int): The width of the generated video, applicable only for CogVideoX1.5-5B-I2V\n    - height (int): The height of the generated video, applicable only for CogVideoX1.5-5B-I2V\n    - guidance_scale (float): The scale for classifier-free guidance. Higher values can lead to better alignment with the prompt.\n    - num_videos_per_prompt (int): Number of videos to generate per prompt.\n    - dtype (torch.dtype): The data type for computation (default is torch.bfloat16).\n    - generate_type (str): The type of video generation (e.g., 't2v', 'i2v', 'v2v').·\n    - seed (int): The seed for reproducibility.\n    - fps (int): The frames per second for the generated video.\n    \"\"\"\n\n    # 1.  Load the pre-trained CogVideoX pipeline with the specified precision (bfloat16).\n    # add device_map=\"balanced\" in the from_pretrained function and remove the enable_model_cpu_offload()\n    # function to use Multi GPUs.\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Generate a video from a text prompt using CogVideoX\"\n    )\n    parser.add_argument(\n        \"--prompt\", type=str, required=True, help=\"The description of the video to be generated\"\n    )\n    parser.add_argument(\n        \"--image_or_video_path\",\n        type=str,\n        default=None,\n        help=\"The path of the image to be used as the background of the video\",\n    )\n    parser.add_argument(\n        \"--model_path\",\n        type=str,\n        default=\"THUDM/CogVideoX-2b\",\n        help=\"Path of the pre-trained model use\",\n    )\n    parser.add_argument(\n        \"--lora_path\", type=str, default=None, help=\"The path of the LoRA weights to be used\"\n    )\n    parser.add_argument(\"--lora_rank\", type=int, default=128, help=\"The rank of the LoRA weights\")\n    parser.add_argument(\n        \"--output_path\", type=str, default=\"./output.mp4\", help=\"The path save generated video\"\n    )\n    parser.add_argument(\n        \"--guidance_scale\", type=float, default=6.0, help=\"The scale for classifier-free guidance\"\n    )\n    parser.add_argument(\"--num_inference_steps\", type=int, default=50, help=\"Inference steps\")\n    parser.add_argument(\n        \"--num_frames\", type=int, default=81, help=\"Number of steps for the inference process\"\n    )\n    parser.add_argument(\"--width\", type=int, default=None, help=\"The width of the generated video\")\n    parser.add_argument(\n        \"--height\", type=int, default=None, help=\"The height of the generated video\"\n    )\n    parser.add_argument(\n        \"--fps\", type=int, default=16, help=\"The frames per second for the generated video\"\n    )\n    parser.add_argument(\n        \"--num_videos_per_prompt\",\n        type=int,\n        default=1,\n        help=\"Number of videos to generate per prompt\",\n    )\n    parser.add_argument(\n        \"--generate_type\", type=str, default=\"t2v\", help=\"The type of video generation\"\n    )\n    parser.add_argument(\n        \"--dtype\", type=str, default=\"bfloat16\", help=\"The data type for computation\"\n    )\n    parser.add_argument(\"--seed\", type=int, default=42, help=\"The seed for reproducibility\")\n\n    args = parser.parse_args()\n    dtype = torch.float16 if args.dtype == \"float16\" else torch.bfloat16\n    generate_video(\n        prompt=args.prompt,\n        model_path=args.model_path,\n        lora_path=args.lora_path,\n        lora_rank=args.lora_rank,\n        output_path=args.output_path,\n        num_frames=args.num_frames,\n        width=args.width,\n        height=args.height,\n        image_or_video_path=args.image_or_video_path,\n        num_inference_steps=args.num_inference_steps,\n        guidance_scale=args.guidance_scale,\n        num_videos_per_prompt=args.num_videos_per_prompt,\n        dtype=dtype,\n        generate_type=args.generate_type,\n        seed=args.seed,\n        fps=args.fps,\n    )\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/CogVideo/inference/cli_demo.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "generate_video",
            "Description": "generate_video",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/CogVideo/inference/cli_demo.py",
            "Implementation": "\"\"\"\nThis script demonstrates how to generate a video using the CogVideoX model with the Hugging Face `diffusers` pipeline.\nThe script supports different types of video generation, including text-to-video (t2v), image-to-video (i2v),\nand video-to-video (v2v), depending on the input data and different weight.\n\n- text-to-video: THUDM/CogVideoX-5b, THUDM/CogVideoX-2b or THUDM/CogVideoX1.5-5b\n- video-to-video: THUDM/CogVideoX-5b, THUDM/CogVideoX-2b or THUDM/CogVideoX1.5-5b\n- image-to-video: THUDM/CogVideoX-5b-I2V or THUDM/CogVideoX1.5-5b-I2V\n\nRunning the Script:\nTo run the script, use the following command with appropriate arguments:\n\n```bash\n$ python cli_demo.py --prompt \"A girl riding a bike.\" --model_path THUDM/CogVideoX1.5-5b --generate_type \"t2v\"\n```\n\nYou can change `pipe.enable_sequential_cpu_offload()` to `pipe.enable_model_cpu_offload()` to speed up inference, but this will use more GPU memory\n\nAdditional options are available to specify the model path, guidance scale, number of inference steps, video generation type, and output paths.\n\n\"\"\"\n\nimport argparse\nimport logging\nfrom typing import Literal, Optional\n\nimport torch\n\nfrom diffusers import (\n    CogVideoXDPMScheduler,\n    CogVideoXImageToVideoPipeline,\n    CogVideoXPipeline,\n    CogVideoXVideoToVideoPipeline,\n)\nfrom diffusers.utils import export_to_video, load_image, load_video\n\n\nlogging.basicConfig(level=logging.INFO)\n\n# Recommended resolution for each model (width, height)\nRESOLUTION_MAP = {\n    # cogvideox1.5-*\n    \"cogvideox1.5-5b-i2v\": (768, 1360),\n    \"cogvideox1.5-5b\": (768, 1360),\n    # cogvideox-*\n    \"cogvideox-5b-i2v\": (480, 720),\n    \"cogvideox-5b\": (480, 720),\n    \"cogvideox-2b\": (480, 720),\n}\n\n\ndef generate_video(\n    prompt: str,\n    model_path: str,\n    lora_path: str = None,\n    lora_rank: int = 128,\n    num_frames: int = 81,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    output_path: str = \"./output.mp4\",\n    image_or_video_path: str = \"\",\n    num_inference_steps: int = 50,\n    guidance_scale: float = 6.0,\n    num_videos_per_prompt: int = 1,\n    dtype: torch.dtype = torch.bfloat16,\n    generate_type: str = Literal[\"t2v\", \"i2v\", \"v2v\"],  # i2v: image to video, v2v: video to video\n    seed: int = 42,\n    fps: int = 16,\n):\n    \"\"\"\n    Generates a video based on the given prompt and saves it to the specified path.\n\n    Parameters:\n    - prompt (str): The description of the video to be generated.\n    - model_path (str): The path of the pre-trained model to be used.\n    - lora_path (str): The path of the LoRA weights to be used.\n    - lora_rank (int): The rank of the LoRA weights.\n    - output_path (str): The path where the generated video will be saved.\n    - num_inference_steps (int): Number of steps for the inference process. More steps can result in better quality.\n    - num_frames (int): Number of frames to generate. CogVideoX1.0 generates 49 frames for 6 seconds at 8 fps, while CogVideoX1.5 produces either 81 or 161 frames, corresponding to 5 seconds or 10 seconds at 16 fps.\n    - width (int): The width of the generated video, applicable only for CogVideoX1.5-5B-I2V\n    - height (int): The height of the generated video, applicable only for CogVideoX1.5-5B-I2V\n    - guidance_scale (float): The scale for classifier-free guidance. Higher values can lead to better alignment with the prompt.\n    - num_videos_per_prompt (int): Number of videos to generate per prompt.\n    - dtype (torch.dtype): The data type for computation (default is torch.bfloat16).\n    - generate_type (str): The type of video generation (e.g., 't2v', 'i2v', 'v2v').·\n    - seed (int): The seed for reproducibility.\n    - fps (int): The frames per second for the generated video.\n    \"\"\"\n\n    # 1.  Load the pre-trained CogVideoX pipeline with the specified precision (bfloat16).\n    # add device_map=\"balanced\" in the from_pretrained function and remove the enable_model_cpu_offload()\n    # function to use Multi GPUs.\n\n    image = None\n    video = None\n\n    model_name = model_path.split(\"/\")[-1].lower()\n    desired_resolution = RESOLUTION_MAP[model_name]\n    if width is None or height is None:\n        height, width = desired_resolution\n        logging.info(\n            f\"\\033[1mUsing default resolution {desired_resolution} for {model_name}\\033[0m\"\n        )\n    elif (height, width) != desired_resolution:\n        if generate_type == \"i2v\":\n            # For i2v models, use user-defined width and height\n            logging.warning(\n                f\"\\033[1;31mThe width({width}) and height({height}) are not recommended for {model_name}. The best resolution is {desired_resolution}.\\033[0m\"\n            )\n        else:\n            # Otherwise, use the recommended width and height\n            logging.warning(\n                f\"\\033[1;31m{model_name} is not supported for custom resolution. Setting back to default resolution {desired_resolution}.\\033[0m\"\n            )\n            height, width = desired_resolution\n\n    if generate_type == \"i2v\":\n        pipe = CogVideoXImageToVideoPipeline.from_pretrained(model_path, torch_dtype=dtype)\n        image = load_image(image=image_or_video_path)\n    elif generate_type == \"t2v\":\n        pipe = CogVideoXPipeline.from_pretrained(model_path, torch_dtype=dtype)\n    else:\n        pipe = CogVideoXVideoToVideoPipeline.from_pretrained(model_path, torch_dtype=dtype)\n        video = load_video(image_or_video_path)\n\n    # If you're using with lora, add this code\n    if lora_path:\n        pipe.load_lora_weights(\n            lora_path, weight_name=\"pytorch_lora_weights.safetensors\", adapter_name=\"test_1\"\n        )\n        pipe.fuse_lora(components=[\"transformer\"], lora_scale=1.0)\n\n    # 2. Set Scheduler.\n    # Can be changed to `CogVideoXDPMScheduler` or `CogVideoXDDIMScheduler`.\n    # We recommend using `CogVideoXDDIMScheduler` for CogVideoX-2B.\n    # using `CogVideoXDPMScheduler` for CogVideoX-5B / CogVideoX-5B-I2V.\n\n    # pipe.scheduler = CogVideoXDDIMScheduler.from_config(pipe.scheduler.config, timestep_spacing=\"trailing\")\n    pipe.scheduler = CogVideoXDPMScheduler.from_config(\n        pipe.scheduler.config, timestep_spacing=\"trailing\"\n    )\n\n    # 3. Enable CPU offload for the model.\n    # turn off if you have multiple GPUs or enough GPU memory(such as H100) and it will cost less time in inference\n    # and enable to(\"cuda\")\n    # pipe.to(\"cuda\")\n\n    # pipe.enable_model_cpu_offload()\n    pipe.enable_sequential_cpu_offload()\n    pipe.vae.enable_slicing()\n    pipe.vae.enable_tiling()\n\n    # 4. Generate the video frames based on the prompt.\n    # `num_frames` is the Number of frames to generate.\n    if generate_type == \"i2v\":\n        video_generate = pipe(\n            height=height,\n            width=width,\n            prompt=prompt,\n            image=image,\n            # The path of the image, the resolution of video will be the same as the image for CogVideoX1.5-5B-I2V, otherwise it will be 720 * 480\n            num_videos_per_prompt=num_videos_per_prompt,  # Number of videos to generate per prompt\n            num_inference_steps=num_inference_steps,  # Number of inference steps\n            num_frames=num_frames,  # Number of frames to generate\n            use_dynamic_cfg=True,  # This id used for DPM scheduler, for DDIM scheduler, it should be False\n            guidance_scale=guidance_scale,\n            generator=torch.Generator().manual_seed(seed),  # Set the seed for reproducibility\n        ).frames[0]\n    elif generate_type == \"t2v\":\n        video_generate = pipe(\n            height=height,\n            width=width,\n            prompt=prompt,\n            num_videos_per_prompt=num_videos_per_prompt,\n            num_inference_steps=num_inference_steps,\n            num_frames=num_frames,\n            use_dynamic_cfg=True,\n            guidance_scale=guidance_scale,\n            generator=torch.Generator().manual_seed(seed),\n        ).frames[0]\n    else:\n        video_generate = pipe(\n            height=height,\n            width=width,\n            prompt=prompt,\n            video=video,  # The path of the video to be used as the background of the video\n            num_videos_per_prompt=num_videos_per_prompt,\n            num_inference_steps=num_inference_steps,\n            num_frames=num_frames,\n            use_dynamic_cfg=True,\n            guidance_scale=guidance_scale,\n            generator=torch.Generator().manual_seed(seed),  # Set the seed for reproducibility\n        ).frames[0]\n    export_to_video(video_generate, output_path, fps=fps)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Generate a video from a text prompt using CogVideoX\"\n    )\n    parser.add_argument(\n        \"--prompt\", type=str, required=True, help=\"The description of the video to be generated\"\n    )\n    parser.add_argument(\n        \"--image_or_video_path\",\n        type=str,\n        default=None,\n        help=\"The path of the image to be used as the background of the video\",\n    )\n    parser.add_argument(\n        \"--model_path\",\n        type=str,\n        default=\"THUDM/CogVideoX-2b\",\n        help=\"Path of the pre-trained model use\",\n    )\n    parser.add_argument(\n        \"--lora_path\", type=str, default=None, help=\"The path of the LoRA weights to be used\"\n    )\n    parser.add_argument(\"--lora_rank\", type=int, default=128, help=\"The rank of the LoRA weights\")\n    parser.add_argument(\n        \"--output_path\", type=str, default=\"./output.mp4\", help=\"The path save generated video\"\n    )\n    parser.add_argument(\n        \"--guidance_scale\", type=float, default=6.0, help=\"The scale for classifier-free guidance\"\n    )\n    parser.add_argument(\"--num_inference_steps\", type=int, default=50, help=\"Inference steps\")\n    parser.add_argument(\n        \"--num_frames\", type=int, default=81, help=\"Number of steps for the inference process\"\n    )\n    parser.add_argument(\"--width\", type=int, default=None, help=\"The width of the generated video\")\n    parser.add_argument(\n        \"--height\", type=int, default=None, help=\"The height of the generated video\"\n    )\n    parser.add_argument(\n        \"--fps\", type=int, default=16, help=\"The frames per second for the generated video\"\n    )\n    parser.add_argument(\n        \"--num_videos_per_prompt\",\n        type=int,\n        default=1,\n        help=\"Number of videos to generate per prompt\",\n    )\n    parser.add_argument(\n        \"--generate_type\", type=str, default=\"t2v\", help=\"The type of video generation\"\n    )\n    parser.add_argument(\n        \"--dtype\", type=str, default=\"bfloat16\", help=\"The data type for computation\"\n    )\n    parser.add_argument(\"--seed\", type=int, default=42, help=\"The seed for reproducibility\")\n\n    args = parser.parse_args()\n    dtype = torch.float16 if args.dtype == \"float16\" else torch.bfloat16\n    generate_video(\n        prompt=args.prompt,\n        model_path=args.model_path,\n        lora_path=args.lora_path,\n        lora_rank=args.lora_rank,\n        output_path=args.output_path,\n        num_frames=args.num_frames,\n        width=args.width,\n        height=args.height,\n        image_or_video_path=args.image_or_video_path,\n        num_inference_steps=args.num_inference_steps,\n        guidance_scale=args.guidance_scale,\n        num_videos_per_prompt=args.num_videos_per_prompt,\n        dtype=dtype,\n        generate_type=args.generate_type,\n        seed=args.seed,\n        fps=args.fps,\n    )\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}