{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/PaddleSpeech",
    "API_Calls": [
        {
            "Name": "call_ASRExecutor",
            "Description": "use ASRExecutor to execute Automatic Speech Recognition tasks.",
            "Code": "# Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport paddle\n\nfrom paddlespeech.cli.asr import ASRExecutor\nfrom paddlespeech.cli.text import TextExecutor\n\n# yapf: disable\nparser = argparse.ArgumentParser(__doc__)\nparser.add_argument(\"--input\", type=str, required=True)\nparser.add_argument(\"--device\", type=str, default=paddle.get_device())\nargs = parser.parse_args()\n# yapf: enable\n\nif __name__ == \"__main__\":\n    asr_executor = ASRExecutor()\n    text_executor = TextExecutor()\n\n    text = asr_executor(\n        audio_file=os.path.abspath(os.path.expanduser(args.input)),\n        device=args.device)\n    result = text_executor(\n        text=text,\n        task='punc',\n        model='ernie_linear_p3_wudao',\n        device=args.device)\n\n    print('ASR Result: \\n{}'.format(text))\n    print('Text Result: \\n{}'.format(result))\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/PaddleSpeech/demos/automatic_video_subtitiles/recognize.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "ASRExecutor",
            "Description": "ASRExecutor impl to execute Automatic Speech Recognition tasks.",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/PaddleSpeech/paddlespeech/cli/asr/infer.py",
            "Implementation": "# Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport io\nimport os\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Union\n\nimport librosa\nimport numpy as np\nimport paddle\nimport soundfile\nfrom yacs.config import CfgNode\n\nfrom paddlespeech.utils.env import MODEL_HOME\nfrom paddlespeech.cli.download import get_path_from_url\nfrom paddlespeech.cli.executor import BaseExecutor\nfrom paddlespeech.cli.log import logger\nfrom paddlespeech.cli.utils import CLI_TIMER\nfrom paddlespeech.cli.utils import stats_wrapper\nfrom paddlespeech.cli.utils import timer_register\nfrom paddlespeech.audio.transform.transformation import Transformation\nfrom paddlespeech.s2t.frontend.featurizer.text_featurizer import TextFeaturizer\nfrom paddlespeech.s2t.utils.utility import UpdateConfig\n\n__all__ = ['ASRExecutor']\n\n\n@timer_register\nclass ASRExecutor(BaseExecutor):\n    def __init__(self):\n        super().__init__(task='asr', inference_type='offline')\n        self.parser = argparse.ArgumentParser(\n            prog='paddlespeech.asr', add_help=True)\n        self.parser.add_argument(\n            '--input', type=str, default=None, help='Audio file to recognize.')\n        self.parser.add_argument(\n            '--model',\n            type=str,\n            default='conformer_u2pp_online_wenetspeech',\n            choices=[\n                tag[:tag.index('-')]\n                for tag in self.task_resource.pretrained_models.keys()\n            ],\n            help='Choose model type of asr task.')\n        self.parser.add_argument(\n            '--lang',\n            type=str,\n            default='zh',\n            help='Choose model language. [zh, en, zh_en], zh:[conformer_wenetspeech-zh-16k], en:[transformer_librispeech-en-16k], zh_en:[conformer_talcs-codeswitch_zh_en-16k]'\n        )\n        self.parser.add_argument(\n            '--codeswitch',\n            type=bool,\n            default=False,\n            help='Choose whether use code-switch. True or False.')\n        self.parser.add_argument(\n            \"--sample_rate\",\n            type=int,\n            default=16000,\n            choices=[8000, 16000],\n            help='Choose the audio sample rate of the model. 8000 or 16000')\n        self.parser.add_argument(\n            '--config',\n            type=str,\n            default=None,\n            help='Config of asr task. Use default config when it is None.')\n        self.parser.add_argument(\n            '--decode_method',\n            type=str,\n            default='attention_rescoring',\n            choices=[\n                'ctc_greedy_search', 'ctc_prefix_beam_search', 'attention',\n                'attention_rescoring'\n            ],\n            help='only support transformer and conformer model')\n        self.parser.add_argument(\n            '--num_decoding_left_chunks',\n            '-num_left',\n            type=str,\n            default=-1,\n            help='only support transformer and conformer online model')\n        self.parser.add_argument(\n            '--ckpt_path',\n            type=str,\n            default=None,\n            help='Checkpoint file of model.')\n        self.parser.add_argument(\n            '--yes',\n            '-y',\n            action=\"store_true\",\n            default=False,\n            help='No additional parameters required. \\\n            Once set this parameter, it means accepting the request of the program by default, \\\n            which includes transforming the audio sample rate')\n        self.parser.add_argument(\n            '--rtf',\n            action=\"store_true\",\n            default=False,\n            help='Show Real-time Factor(RTF).')\n        self.parser.add_argument(\n            '--device',\n            type=str,\n            default=paddle.get_device(),\n            help='Choose device to execute model inference.')\n        self.parser.add_argument(\n            '-d',\n            '--job_dump_result',\n            action='store_true',\n            help='Save job result into file.')\n        self.parser.add_argument(\n            '-v',\n            '--verbose',\n            action='store_true',\n            help='Increase logger verbosity of current task.')\n\n    def _init_from_path(self,\n                        model_type: str='wenetspeech',\n                        lang: str='zh',\n                        codeswitch: bool=False,\n                        sample_rate: int=16000,\n                        cfg_path: Optional[os.PathLike]=None,\n                        decode_method: str='attention_rescoring',\n                        num_decoding_left_chunks: int=-1,\n                        ckpt_path: Optional[os.PathLike]=None):\n        \"\"\"\n        Init model and other resources from a specific path.\n        \"\"\"\n        logger.debug(\"start to init the model\")\n        # default max_len: unit:second\n        self.max_len = 50\n        if hasattr(self, 'model'):\n            logger.debug('Model had been initialized.')\n            return\n\n        if cfg_path is None or ckpt_path is None:\n            sample_rate_str = '16k' if sample_rate == 16000 else '8k'\n            if lang == \"zh_en\" and codeswitch is True:\n                tag = model_type + '-' + 'codeswitch_' + lang + '-' + sample_rate_str\n            elif lang == \"zh_en\" or codeswitch is True:\n                raise Exception(\"codeswitch is true only in zh_en model\")\n            else:\n                tag = model_type + '-' + lang + '-' + sample_rate_str\n            self.task_resource.set_task_model(tag, version=None)\n            self.res_path = self.task_resource.res_dir\n\n            self.cfg_path = os.path.join(\n                self.res_path, self.task_resource.res_dict['cfg_path'])\n            self.ckpt_path = os.path.join(\n                self.res_path,\n                self.task_resource.res_dict['ckpt_path'] + \".pdparams\")\n            logger.debug(self.res_path)\n\n        else:\n            self.cfg_path = os.path.abspath(cfg_path)\n            self.ckpt_path = os.path.abspath(ckpt_path + \".pdparams\")\n            self.res_path = os.path.dirname(\n                os.path.dirname(os.path.abspath(self.cfg_path)))\n        logger.debug(self.cfg_path)\n        logger.debug(self.ckpt_path)\n\n        #Init body.\n        self.config = CfgNode(new_allowed=True)\n        self.config.merge_from_file(self.cfg_path)\n\n        with UpdateConfig(self.config):\n            if self.config.spm_model_prefix:\n                self.config.spm_model_prefix = os.path.join(\n                    self.res_path, self.config.spm_model_prefix)\n            self.text_feature = TextFeaturizer(\n                unit_type=self.config.unit_type,\n                vocab=self.config.vocab_filepath,\n                spm_model_prefix=self.config.spm_model_prefix)\n            if \"deepspeech2\" in model_type:\n                self.config.decode.lang_model_path = os.path.join(\n                    MODEL_HOME, 'language_model',\n                    self.config.decode.lang_model_path)\n\n                lm_url = self.task_resource.res_dict['lm_url']\n                lm_md5 = self.task_resource.res_dict['lm_md5']\n                self.download_lm(\n                    lm_url,\n                    os.path.dirname(self.config.decode.lang_model_path), lm_md5)\n\n            elif \"conformer\" in model_type or \"transformer\" in model_type:\n                self.config.decode.decoding_method = decode_method\n                if num_decoding_left_chunks:\n                    assert num_decoding_left_chunks == -1 or num_decoding_left_chunks >= 0, \"num_decoding_left_chunks should be -1 or >=0\"\n                    self.config.num_decoding_left_chunks = num_decoding_left_chunks\n\n            else:\n                raise Exception(\"wrong type\")\n        model_name = model_type[:model_type.rindex(\n            '_')]  # model_type: {model_name}_{dataset}\n        model_class = self.task_resource.get_model_class(model_name)\n        model_conf = self.config\n        model = model_class.from_config(model_conf)\n        self.model = model\n        self.model.eval()\n\n        # load model\n        model_dict = paddle.load(self.ckpt_path)\n        self.model.set_state_dict(model_dict)\n\n        # compute the max len limit\n        if \"conformer\" in model_type or \"transformer\" in model_type:\n            # in transformer like model, we may use the subsample rate cnn network\n            subsample_rate = self.model.subsampling_rate()\n            frame_shift_ms = self.config.preprocess_config.process[0][\n                'n_shift'] / self.config.preprocess_config.process[0]['fs']\n            max_len = self.model.encoder.embed.pos_enc.max_len\n\n            if self.config.encoder_conf.get(\"max_len\", None):\n                max_len = self.config.encoder_conf.max_len\n\n            self.max_len = frame_shift_ms * max_len * subsample_rate\n            logger.debug(\n                f\"The asr server limit max duration len: {self.max_len}\")\n\n    def preprocess(self, model_type: str, input: Union[str, os.PathLike]):\n        \"\"\"\n        Input preprocess and return paddle.Tensor stored in self.input.\n        Input content can be a text(tts), a file(asr, cls) or a streaming(not supported yet).\n        \"\"\"\n\n        audio_file = input\n        if isinstance(audio_file, (str, os.PathLike)):\n            logger.debug(\"Preprocess audio_file:\" + audio_file)\n        elif isinstance(audio_file, io.BytesIO):\n            audio_file.seek(0)\n\n        # Get the object for feature extraction\n        if \"deepspeech2\" in model_type or \"conformer\" in model_type or \"transformer\" in model_type:\n            logger.debug(\"get the preprocess conf\")\n            preprocess_conf = self.config.preprocess_config\n            preprocess_args = {\"train\": False}\n            preprocessing = Transformation(preprocess_conf)\n            logger.debug(\"read the audio file\")\n            audio, audio_sample_rate = soundfile.read(\n                audio_file, dtype=\"int16\", always_2d=True)\n            if self.change_format:\n                if audio.shape[1] >= 2:\n                    audio = audio.mean(axis=1, dtype=np.int16)\n                else:\n                    audio = audio[:, 0]\n                # pcm16 -> pcm 32\n                audio = self._pcm16to32(audio)\n                audio = librosa.resample(\n                    audio,\n                    orig_sr=audio_sample_rate,\n                    target_sr=self.sample_rate)\n                audio_sample_rate = self.sample_rate\n                # pcm32 -> pcm 16\n                audio = self._pcm32to16(audio)\n            else:\n                audio = audio[:, 0]\n\n            logger.debug(f\"audio shape: {audio.shape}\")\n            # fbank\n            audio = preprocessing(audio, **preprocess_args)\n\n            audio_len = paddle.to_tensor(audio.shape[0]).unsqueeze(axis=0)\n            audio = paddle.to_tensor(audio, dtype='float32').unsqueeze(axis=0)\n\n            self._inputs[\"audio\"] = audio\n            self._inputs[\"audio_len\"] = audio_len\n            logger.debug(f\"audio feat shape: {audio.shape}\")\n\n        else:\n            raise Exception(\"wrong type\")\n\n        logger.debug(\"audio feat process success\")\n\n    @paddle.no_grad()\n    def infer(self, model_type: str):\n        \"\"\"\n        Model inference and result stored in self.output.\n        \"\"\"\n        logger.debug(\"start to infer the model to get the output\")\n        cfg = self.config.decode\n        audio = self._inputs[\"audio\"]\n        audio_len = self._inputs[\"audio_len\"]\n        if \"deepspeech2\" in model_type:\n            decode_batch_size = audio.shape[0]\n            self.model.decoder.init_decoder(\n                decode_batch_size, self.text_feature.vocab_list,\n                cfg.decoding_method, cfg.lang_model_path, cfg.alpha, cfg.beta,\n                cfg.beam_size, cfg.cutoff_prob, cfg.cutoff_top_n,\n                cfg.num_proc_bsearch)\n\n            result_transcripts = self.model.decode(audio, audio_len)\n            self.model.decoder.del_decoder()\n            self._outputs[\"result\"] = result_transcripts[0]\n\n        elif \"conformer\" in model_type or \"transformer\" in model_type:\n            logger.debug(\n                f\"we will use the transformer like model : {model_type}\")\n            try:\n                result_transcripts = self.model.decode(\n                    audio,\n                    audio_len,\n                    text_feature=self.text_feature,\n                    decoding_method=cfg.decoding_method,\n                    beam_size=cfg.beam_size,\n                    ctc_weight=cfg.ctc_weight,\n                    decoding_chunk_size=cfg.decoding_chunk_size,\n                    num_decoding_left_chunks=cfg.num_decoding_left_chunks,\n                    simulate_streaming=cfg.simulate_streaming)\n                self._outputs[\"result\"] = result_transcripts[0][0]\n            except Exception as e:\n                logger.exception(e)\n\n        else:\n            raise Exception(\"invalid model name\")\n\n    def postprocess(self) -> Union[str, os.PathLike]:\n        \"\"\"\n            Output postprocess and return human-readable results such as texts and audio files.\n        \"\"\"\n        return self._outputs[\"result\"]\n\n    def download_lm(self, url, lm_dir, md5sum):\n        download_path = get_path_from_url(\n            url=url,\n            root_dir=lm_dir,\n            md5sum=md5sum,\n            decompress=False, )\n\n    def _pcm16to32(self, audio):\n        assert (audio.dtype == np.int16)\n        audio = audio.astype(\"float32\")\n        bits = np.iinfo(np.int16).bits\n        audio = audio / (2**(bits - 1))\n        return audio\n\n    def _pcm32to16(self, audio):\n        assert (audio.dtype == np.float32)\n        bits = np.iinfo(np.int16).bits\n        audio = audio * (2**(bits - 1))\n        audio = np.round(audio).astype(\"int16\")\n        return audio\n\n    def _check(self, audio_file: str, sample_rate: int, force_yes: bool=False):\n        self.sample_rate = sample_rate\n        if self.sample_rate != 16000 and self.sample_rate != 8000:\n            logger.error(\n                \"invalid sample rate, please input --sr 8000 or --sr 16000\")\n            return False\n\n        if isinstance(audio_file, (str, os.PathLike)):\n            if not os.path.isfile(audio_file):\n                logger.error(\"Please input the right audio file path\")\n                return False\n        elif isinstance(audio_file, io.BytesIO):\n            audio_file.seek(0)\n\n        logger.debug(\"checking the audio file format......\")\n        try:\n            audio, audio_sample_rate = soundfile.read(\n                audio_file, dtype=\"int16\", always_2d=True)\n            audio_duration = audio.shape[0] / audio_sample_rate\n            if audio_duration > self.max_len:\n                logger.error(\n                    f\"Please input audio file less then {self.max_len} seconds.\\n\"\n                )\n                return False\n        except Exception as e:\n            logger.exception(e)\n            logger.error(\n                f\"can not open the audio file, please check the audio file({audio_file}) format is 'wav'. \\n \\\n                 you can try to use sox to change the file format.\\n \\\n                 For example: \\n \\\n                 sample rate: 16k \\n \\\n                 sox input_audio.xx --rate 16k --bits 16 --channels 1 output_audio.wav \\n \\\n                 sample rate: 8k \\n \\\n                 sox input_audio.xx --rate 8k --bits 16 --channels 1 output_audio.wav \\n \\\n                 \")\n            return False\n        logger.debug(\"The sample rate is %d\" % audio_sample_rate)\n        if audio_sample_rate != self.sample_rate:\n            logger.warning(\"The sample rate of the input file is not {}.\\n \\\n                            The program will resample the wav file to {}.\\n \\\n                            If the result does not meet your expectationsï¼Œ\\n \\\n                            Please input the 16k 16 bit 1 channel wav file. \\\n                        \".format(self.sample_rate, self.sample_rate))\n            if force_yes is False:\n                while (True):\n                    logger.debug(\n                        \"Whether to change the sample rate and the channel. Y: change the sample. N: exit the prgream.\"\n                    )\n                    content = input(\"Input(Y/N):\")\n                    if content.strip() == \"Y\" or content.strip(\n                    ) == \"y\" or content.strip() == \"yes\" or content.strip(\n                    ) == \"Yes\":\n                        logger.debug(\n                            \"change the sampele rate, channel to 16k and 1 channel\"\n                        )\n                        break\n                    elif content.strip() == \"N\" or content.strip(\n                    ) == \"n\" or content.strip() == \"no\" or content.strip(\n                    ) == \"No\":\n                        logger.debug(\"Exit the program\")\n                        return False\n                    else:\n                        logger.warning(\"Not regular input, please input again\")\n\n            self.change_format = True\n        else:\n            logger.debug(\"The audio file format is right\")\n            self.change_format = False\n\n        return True\n\n    def execute(self, argv: List[str]) -> bool:\n        \"\"\"\n            Command line entry.\n        \"\"\"\n        parser_args = self.parser.parse_args(argv)\n\n        model = parser_args.model\n        lang = parser_args.lang\n        codeswitch = parser_args.codeswitch\n        sample_rate = parser_args.sample_rate\n        config = parser_args.config\n        ckpt_path = parser_args.ckpt_path\n        decode_method = parser_args.decode_method\n        force_yes = parser_args.yes\n        rtf = parser_args.rtf\n        device = parser_args.device\n\n        if not parser_args.verbose:\n            self.disable_task_loggers()\n\n        task_source = self.get_input_source(parser_args.input)\n        task_results = OrderedDict()\n        has_exceptions = False\n\n        for id_, input_ in task_source.items():\n            try:\n                res = self(\n                    audio_file=input_,\n                    model=model,\n                    lang=lang,\n                    codeswitch=codeswitch,\n                    sample_rate=sample_rate,\n                    config=config,\n                    ckpt_path=ckpt_path,\n                    decode_method=decode_method,\n                    force_yes=force_yes,\n                    rtf=rtf,\n                    device=device)\n                task_results[id_] = res\n            except Exception as e:\n                has_exceptions = True\n                task_results[id_] = f'{e.__class__.__name__}: {e}'\n\n        if rtf:\n            self.show_rtf(CLI_TIMER[self.__class__.__name__])\n\n        self.process_task_results(parser_args.input, task_results,\n                                  parser_args.job_dump_result)\n\n        if has_exceptions:\n            return False\n        else:\n            return True\n\n    @stats_wrapper\n    def __call__(self,\n                 audio_file: os.PathLike,\n                 model: str='conformer_u2pp_online_wenetspeech',\n                 lang: str='zh',\n                 codeswitch: bool=False,\n                 sample_rate: int=16000,\n                 config: os.PathLike=None,\n                 ckpt_path: os.PathLike=None,\n                 decode_method: str='attention_rescoring',\n                 num_decoding_left_chunks: int=-1,\n                 force_yes: bool=False,\n                 rtf: bool=False,\n                 device=paddle.get_device()):\n        \"\"\"\n        Python API to call an executor.\n        \"\"\"\n        audio_file = os.path.abspath(audio_file)\n        paddle.set_device(device)\n        self._init_from_path(model, lang, codeswitch, sample_rate, config,\n                             decode_method, num_decoding_left_chunks, ckpt_path)\n        if not self._check(audio_file, sample_rate, force_yes):\n            sys.exit(-1)\n        if rtf:\n            k = self.__class__.__name__\n            CLI_TIMER[k]['start'].append(time.time())\n\n        self.preprocess(model, audio_file)\n        self.infer(model)\n        res = self.postprocess()  # Retrieve result of asr.\n\n        if rtf:\n            CLI_TIMER[k]['end'].append(time.time())\n            audio, audio_sample_rate = soundfile.read(\n                audio_file, dtype=\"int16\", always_2d=True)\n            CLI_TIMER[k]['extra'].append(audio.shape[0] / audio_sample_rate)\n\n        return res\n",
            "Examples": [
                "\n"
            ]
        },
        {
            "Name": "TextExecutor",
            "Description": "TextExecutor impl to execute Text Processing tasks.",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/PaddleSpeech/paddlespeech/cli/text/infer.py",
            "Implementation": "# Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\nimport re\nfrom collections import OrderedDict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Union\n\nimport paddle\nimport yaml\nfrom yacs.config import CfgNode\n\nfrom ..executor import BaseExecutor\nfrom ..log import logger\nfrom ..utils import stats_wrapper\nfrom paddlespeech.text.models.ernie_linear import ErnieLinear\n\n__all__ = ['TextExecutor']\n\n\nclass TextExecutor(BaseExecutor):\n    def __init__(self):\n        super().__init__(task='text')\n        self.parser = argparse.ArgumentParser(\n            prog='paddlespeech.text', add_help=True)\n        self.parser.add_argument(\n            '--input', type=str, default=None, help='Input text.')\n        self.parser.add_argument(\n            '--task',\n            type=str,\n            default='punc',\n            choices=['punc'],\n            help='Choose text task.')\n        self.parser.add_argument(\n            '--model',\n            type=str,\n            default='ernie_linear_p7_wudao',\n            choices=[\n                tag[:tag.index('-')]\n                for tag in self.task_resource.pretrained_models.keys()\n            ],\n            help='Choose model type of text task.')\n        self.parser.add_argument(\n            '--lang',\n            type=str,\n            default='zh',\n            choices=['zh', 'en'],\n            help='Choose model language.')\n        self.parser.add_argument(\n            '--config',\n            type=str,\n            default=None,\n            help='Config of cls task. Use default config when it is None.')\n        self.parser.add_argument(\n            '--ckpt_path',\n            type=str,\n            default=None,\n            help='Checkpoint file of model.')\n        self.parser.add_argument(\n            '--punc_vocab',\n            type=str,\n            default=None,\n            help='Vocabulary file of punctuation restoration task.')\n        self.parser.add_argument(\n            '--device',\n            type=str,\n            default=paddle.get_device(),\n            help='Choose device to execute model inference.')\n        self.parser.add_argument(\n            '-d',\n            '--job_dump_result',\n            action='store_true',\n            help='Save job result into file.')\n        self.parser.add_argument(\n            '-v',\n            '--verbose',\n            action='store_true',\n            help='Increase logger verbosity of current task.')\n\n    def _init_from_path(self,\n                        task: str='punc',\n                        model_type: str='ernie_linear_p7_wudao',\n                        lang: str='zh',\n                        cfg_path: Optional[os.PathLike]=None,\n                        ckpt_path: Optional[os.PathLike]=None,\n                        vocab_file: Optional[os.PathLike]=None):\n        \"\"\"\n            Init model and other resources from a specific path.\n        \"\"\"\n        if hasattr(self, 'model'):\n            logger.debug('Model had been initialized.')\n            return\n\n        self.task = task\n\n        if cfg_path is None or ckpt_path is None or vocab_file is None:\n            tag = '-'.join([model_type, task, lang])\n            self.task_resource.set_task_model(tag, version=None)\n            self.cfg_path = os.path.join(\n                self.task_resource.res_dir,\n                self.task_resource.res_dict['cfg_path'])\n            self.ckpt_path = os.path.join(\n                self.task_resource.res_dir,\n                self.task_resource.res_dict['ckpt_path'])\n            self.vocab_file = os.path.join(\n                self.task_resource.res_dir,\n                self.task_resource.res_dict['vocab_file'])\n        else:\n            self.cfg_path = os.path.abspath(cfg_path)\n            self.ckpt_path = os.path.abspath(ckpt_path)\n            self.vocab_file = os.path.abspath(vocab_file)\n\n        model_name = model_type[:model_type.rindex('_')]\n        if self.task == 'punc':\n            # punc list\n            self._punc_list = []\n            with open(self.vocab_file, 'r', encoding='utf-8') as f:\n                for line in f:\n                    self._punc_list.append(line.strip())\n\n            # model\n            model_class, tokenizer_class = self.task_resource.get_model_class(\n                model_name)\n            self.model = model_class(\n                cfg_path=self.cfg_path, ckpt_path=self.ckpt_path)\n            self.tokenizer = tokenizer_class.from_pretrained('ernie-1.0')\n        else:\n            raise NotImplementedError\n\n        self.model.eval()\n\n    #init new models\n    def _init_from_path_new(self,\n                            task: str='punc',\n                            model_type: str='ernie_linear_p7_wudao',\n                            lang: str='zh',\n                            cfg_path: Optional[os.PathLike]=None,\n                            ckpt_path: Optional[os.PathLike]=None,\n                            vocab_file: Optional[os.PathLike]=None):\n        if hasattr(self, 'model'):\n            logger.debug('Model had been initialized.')\n            return\n\n        self.task = task\n\n        if cfg_path is None or ckpt_path is None or vocab_file is None:\n            tag = '-'.join([model_type, task, lang])\n            self.task_resource.set_task_model(tag, version=None)\n            self.cfg_path = os.path.join(\n                self.task_resource.res_dir,\n                self.task_resource.res_dict['cfg_path'])\n            self.ckpt_path = os.path.join(\n                self.task_resource.res_dir,\n                self.task_resource.res_dict['ckpt_path'])\n            self.vocab_file = os.path.join(\n                self.task_resource.res_dir,\n                self.task_resource.res_dict['vocab_file'])\n        else:\n            self.cfg_path = os.path.abspath(cfg_path)\n            self.ckpt_path = os.path.abspath(ckpt_path)\n            self.vocab_file = os.path.abspath(vocab_file)\n\n        model_name = model_type[:model_type.rindex('_')]\n\n        if self.task == 'punc':\n            # punc list\n            self._punc_list = []\n            with open(self.vocab_file, 'r', encoding='utf-8') as f:\n                for line in f:\n                    self._punc_list.append(line.strip())\n\n            # model\n            with open(self.cfg_path, 'r', encoding='utf-8') as f:\n                config = CfgNode(yaml.safe_load(f))\n            self.model = ErnieLinear(**config[\"model\"])\n\n            _, tokenizer_class = self.task_resource.get_model_class(model_name)\n            state_dict = paddle.load(self.ckpt_path)\n            self.model.set_state_dict(state_dict[\"main_params\"])\n            self.model.eval()\n\n            #tokenizer: fast version: ernie-3.0-mini-zh   slow version:ernie-1.0\n            if 'fast' not in model_type:\n                self.tokenizer = tokenizer_class.from_pretrained('ernie-1.0')\n            else:\n                self.tokenizer = tokenizer_class.from_pretrained(\n                    'ernie-3.0-mini-zh')\n\n        else:\n            raise NotImplementedError\n\n    def _clean_text(self, text):\n        text = text.lower()\n        text = re.sub('[^A-Za-z0-9\\u4e00-\\u9fa5]', '', text)\n        text = re.sub(f'[{\"\".join([p for p in self._punc_list][1:])}]', '',\n                      text)\n        return text\n\n    def preprocess(self, text: Union[str, os.PathLike]):\n        \"\"\"\n            Input preprocess and return paddle.Tensor stored in self.input.\n            Input content can be a text(tts), a file(asr, cls) or a streaming(not supported yet).\n        \"\"\"\n        if self.task == 'punc':\n            clean_text = self._clean_text(text)\n            assert len(clean_text) > 0, f'Invalid input string: {text}'\n\n            tokenized_input = self.tokenizer(\n                list(clean_text), return_length=True, is_split_into_words=True)\n\n            self._inputs['input_ids'] = tokenized_input['input_ids']\n            self._inputs['seg_ids'] = tokenized_input['token_type_ids']\n            self._inputs['seq_len'] = tokenized_input['seq_len']\n        else:\n            raise NotImplementedError\n\n    @paddle.no_grad()\n    def infer(self):\n        \"\"\"\n            Model inference and result stored in self.output.\n        \"\"\"\n        if self.task == 'punc':\n            input_ids = paddle.to_tensor(self._inputs['input_ids']).unsqueeze(0)\n            seg_ids = paddle.to_tensor(self._inputs['seg_ids']).unsqueeze(0)\n            logits, _ = self.model(input_ids, seg_ids)\n            preds = paddle.argmax(logits, axis=-1).squeeze(0)\n\n            self._outputs['preds'] = preds\n        else:\n            raise NotImplementedError\n\n    def postprocess(self, isNewTrainer: bool=False) -> Union[str, os.PathLike]:\n        \"\"\"\n            Output postprocess and return human-readable results such as texts and audio files.\n        \"\"\"\n        if self.task == 'punc':\n            input_ids = self._inputs['input_ids']\n            seq_len = self._inputs['seq_len']\n            preds = self._outputs['preds']\n\n            tokens = self.tokenizer.convert_ids_to_tokens(\n                input_ids[1:seq_len - 1])\n            labels = preds[1:seq_len - 1].tolist()\n            assert len(tokens) == len(labels)\n            if isNewTrainer:\n                self._punc_list = [0] + self._punc_list\n            text = ''\n            for t, l in zip(tokens, labels):\n                text += t\n                if l != 0:  # Non punc.\n                    text += self._punc_list[l]\n            return text\n        else:\n            raise NotImplementedError\n\n    def execute(self, argv: List[str]) -> bool:\n        \"\"\"\n            Command line entry.\n        \"\"\"\n        parser_args = self.parser.parse_args(argv)\n\n        task = parser_args.task\n        model_type = parser_args.model\n        lang = parser_args.lang\n        cfg_path = parser_args.config\n        ckpt_path = parser_args.ckpt_path\n        punc_vocab = parser_args.punc_vocab\n        device = parser_args.device\n\n        if not parser_args.verbose:\n            self.disable_task_loggers()\n\n        task_source = self.get_input_source(parser_args.input)\n        task_results = OrderedDict()\n        has_exceptions = False\n\n        for id_, input_ in task_source.items():\n            try:\n                res = self(input_, task, model_type, lang, cfg_path, ckpt_path,\n                           punc_vocab, device)\n                task_results[id_] = res\n            except Exception as e:\n                has_exceptions = True\n                task_results[id_] = f'{e.__class__.__name__}: {e}'\n\n        self.process_task_results(parser_args.input, task_results,\n                                  parser_args.job_dump_result)\n\n        if has_exceptions:\n            return False\n        else:\n            return True\n\n    @stats_wrapper\n    def __call__(\n            self,\n            text: str,\n            task: str='punc',\n            model: str='ernie_linear_p7_wudao',\n            lang: str='zh',\n            config: Optional[os.PathLike]=None,\n            ckpt_path: Optional[os.PathLike]=None,\n            punc_vocab: Optional[os.PathLike]=None,\n            device: str=paddle.get_device(), ):\n        \"\"\"\n            Python API to call an executor.\n        \"\"\"\n        #Here is old version models \n        if model in ['ernie_linear_p7_wudao', 'ernie_linear_p3_wudao']:\n            paddle.set_device(device)\n            self._init_from_path(task, model, lang, config, ckpt_path,\n                                 punc_vocab)\n            self.preprocess(text)\n            self.infer()\n            res = self.postprocess()  # Retrieve result of text task.\n        #Add new way to infer\n        else:\n            paddle.set_device(device)\n            self._init_from_path_new(task, model, lang, config, ckpt_path,\n                                     punc_vocab)\n            self.preprocess(text)\n            self.infer()\n            res = self.postprocess(isNewTrainer=True)\n        return res\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}