{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/mmpose",
    "API_Calls": [
        {
            "Name": "inferencer_demo",
            "Description": "inferencer_demo",
            "Code": "# Copyright (c) OpenMMLab. All rights reserved.\nfrom argparse import ArgumentParser\nfrom typing import Dict\n\nfrom mmpose.apis.inferencers import MMPoseInferencer, get_model_aliases\n\nfilter_args = dict(bbox_thr=0.3, nms_thr=0.3, pose_based_nms=False)\nPOSE2D_SPECIFIC_ARGS = dict(\n    yoloxpose=dict(bbox_thr=0.01, nms_thr=0.65, pose_based_nms=True),\n    rtmo=dict(bbox_thr=0.1, nms_thr=0.65, pose_based_nms=True),\n)\n\n\ndef parse_args():\n    parser = ArgumentParser()\n    parser.add_argument(\n        'inputs',\n        type=str,\n        nargs='?',\n        help='Input image/video path or folder path.')\n\n    # init args\n    parser.add_argument(\n        '--pose2d',\n        type=str,\n        default=None,\n        help='Pretrained 2D pose estimation algorithm. It\\'s the path to the '\n        'config file or the model name defined in metafile.')\n    parser.add_argument(\n        '--pose2d-weights',\n        type=str,\n        default=None,\n        help='Path to the custom checkpoint file of the selected pose model. '\n        'If it is not specified and \"pose2d\" is a model name of metafile, '\n        'the weights will be loaded from metafile.')\n    parser.add_argument(\n        '--pose3d',\n        type=str,\n        default=None,\n        help='Pretrained 3D pose estimation algorithm. It\\'s the path to the '\n        'config file or the model name defined in metafile.')\n    parser.add_argument(\n        '--pose3d-weights',\n        type=str,\n        default=None,\n        help='Path to the custom checkpoint file of the selected pose model. '\n        'If it is not specified and \"pose3d\" is a model name of metafile, '\n        'the weights will be loaded from metafile.')\n    parser.add_argument(\n        '--det-model',\n        type=str,\n        default=None,\n        help='Config path or alias of detection model.')\n    parser.add_argument(\n        '--det-weights',\n        type=str,\n        default=None,\n        help='Path to the checkpoints of detection model.')\n    parser.add_argument(\n        '--det-cat-ids',\n        type=int,\n        nargs='+',\n        default=0,\n        help='Category id for detection model.')\n    parser.add_argument(\n        '--scope',\n        type=str,\n        default='mmpose',\n        help='Scope where modules are defined.')\n    parser.add_argument(\n        '--device',\n        type=str,\n        default=None,\n        help='Device used for inference. '\n        'If not specified, the available device will be automatically used.')\n    parser.add_argument(\n        '--show-progress',\n        action='store_true',\n        help='Display the progress bar during inference.')\n\n    # The default arguments for prediction filtering differ for top-down\n    # and bottom-up models. We assign the default arguments according to the\n    # selected pose2d model\n    args, _ = parser.parse_known_args()\n    for model in POSE2D_SPECIFIC_ARGS:\n        if args.pose2d is not None and model in args.pose2d:\n            filter_args.update(POSE2D_SPECIFIC_ARGS[model])\n            break\n\n    # call args\n    parser.add_argument(\n        '--show',\n        action='store_true',\n        help='Display the image/video in a popup window.')\n    parser.add_argument(\n        '--draw-bbox',\n        action='store_true',\n        help='Whether to draw the bounding boxes.')\n    parser.add_argument(\n        '--draw-heatmap',\n        action='store_true',\n        default=False,\n        help='Whether to draw the predicted heatmaps.')\n    parser.add_argument(\n        '--bbox-thr',\n        type=float,\n        default=filter_args['bbox_thr'],\n        help='Bounding box score threshold')\n    parser.add_argument(\n        '--nms-thr',\n        type=float,\n        default=filter_args['nms_thr'],\n        help='IoU threshold for bounding box NMS')\n    parser.add_argument(\n        '--pose-based-nms',\n        type=lambda arg: arg.lower() in ('true', 'yes', 't', 'y', '1'),\n        default=filter_args['pose_based_nms'],\n        help='Whether to use pose-based NMS')\n    parser.add_argument(\n        '--kpt-thr', type=float, default=0.3, help='Keypoint score threshold')\n    parser.add_argument(\n        '--tracking-thr', type=float, default=0.3, help='Tracking threshold')\n    parser.add_argument(\n        '--use-oks-tracking',\n        action='store_true',\n        help='Whether to use OKS as similarity in tracking')\n    parser.add_argument(\n        '--disable-norm-pose-2d',\n        action='store_true',\n        help='Whether to scale the bbox (along with the 2D pose) to the '\n        'average bbox scale of the dataset, and move the bbox (along with the '\n        '2D pose) to the average bbox center of the dataset. This is useful '\n        'when bbox is small, especially in multi-person scenarios.')\n    parser.add_argument(\n        '--disable-rebase-keypoint',\n        action='store_true',\n        default=False,\n        help='Whether to disable rebasing the predicted 3D pose so its '\n        'lowest keypoint has a height of 0 (landing on the ground). Rebase '\n        'is useful for visualization when the model do not predict the '\n        'global position of the 3D pose.')\n    parser.add_argument(\n        '--num-instances',\n        type=int,\n        default=1,\n        help='The number of 3D poses to be visualized in every frame. If '\n        'less than 0, it will be set to the number of pose results in the '\n        'first frame.')\n    parser.add_argument(\n        '--radius',\n        type=int,\n        default=3,\n        help='Keypoint radius for visualization.')\n    parser.add_argument(\n        '--thickness',\n        type=int,\n        default=1,\n        help='Link thickness for visualization.')\n    parser.add_argument(\n        '--skeleton-style',\n        default='mmpose',\n        type=str,\n        choices=['mmpose', 'openpose'],\n        help='Skeleton style selection')\n    parser.add_argument(\n        '--black-background',\n        action='store_true',\n        help='Plot predictions on a black image')\n    parser.add_argument(\n        '--vis-out-dir',\n        type=str,\n        default='',\n        help='Directory for saving visualized results.')\n    parser.add_argument(\n        '--pred-out-dir',\n        type=str,\n        default='',\n        help='Directory for saving inference results.')\n    parser.add_argument(\n        '--show-alias',\n        action='store_true',\n        help='Display all the available model aliases.')\n\n    call_args = vars(parser.parse_args())\n\n    init_kws = [\n        'pose2d', 'pose2d_weights', 'scope', 'device', 'det_model',\n        'det_weights', 'det_cat_ids', 'pose3d', 'pose3d_weights',\n        'show_progress'\n    ]\n    init_args = {}\n    for init_kw in init_kws:\n        init_args[init_kw] = call_args.pop(init_kw)\n\n    display_alias = call_args.pop('show_alias')\n\n    return init_args, call_args, display_alias\n\n\ndef display_model_aliases(model_aliases: Dict[str, str]) -> None:\n    \"\"\"Display the available model aliases and their corresponding model\n    names.\"\"\"\n    aliases = list(model_aliases.keys())\n    max_alias_length = max(map(len, aliases))\n    print(f'{\"ALIAS\".ljust(max_alias_length+2)}MODEL_NAME')\n    for alias in sorted(aliases):\n        print(f'{alias.ljust(max_alias_length+2)}{model_aliases[alias]}')\n\n\ndef main():\n    init_args, call_args, display_alias = parse_args()\n    if display_alias:\n        model_alises = get_model_aliases(init_args['scope'])\n        display_model_aliases(model_alises)\n    else:\n        inferencer = MMPoseInferencer(**init_args)\n        for _ in inferencer(**call_args):\n            pass\n\n\nif __name__ == '__main__':\n    main()\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/mmpose/demo/inferencer_demo.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "MMPoseInferencer",
            "Description": "MMPoseInferencer",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/mmpose/mmpose/apis/inferencers/mmpose_inferencer.py",
            "Implementation": "# Copyright (c) OpenMMLab. All rights reserved.\nimport warnings\nfrom typing import Dict, List, Optional, Sequence, Union\n\nimport numpy as np\nimport torch\nfrom mmengine.config import Config, ConfigDict\nfrom mmengine.infer.infer import ModelType\nfrom mmengine.structures import InstanceData\nfrom rich.progress import track\n\nfrom .base_mmpose_inferencer import BaseMMPoseInferencer\nfrom .hand3d_inferencer import Hand3DInferencer\nfrom .pose2d_inferencer import Pose2DInferencer\nfrom .pose3d_inferencer import Pose3DInferencer\n\nInstanceList = List[InstanceData]\nInputType = Union[str, np.ndarray]\nInputsType = Union[InputType, Sequence[InputType]]\nPredType = Union[InstanceData, InstanceList]\nImgType = Union[np.ndarray, Sequence[np.ndarray]]\nConfigType = Union[Config, ConfigDict]\nResType = Union[Dict, List[Dict], InstanceData, List[InstanceData]]\n\n\nclass MMPoseInferencer(BaseMMPoseInferencer):\n    \"\"\"MMPose Inferencer. It's a unified inferencer interface for pose\n    estimation task, currently including: Pose2D. and it can be used to perform\n    2D keypoint detection.\n\n    Args:\n        pose2d (str, optional): Pretrained 2D pose estimation algorithm.\n            It's the path to the config file or the model name defined in\n            metafile. For example, it could be:\n\n            - model alias, e.g. ``'body'``,\n            - config name, e.g. ``'simcc_res50_8xb64-210e_coco-256x192'``,\n            - config path\n\n            Defaults to ``None``.\n        pose2d_weights (str, optional): Path to the custom checkpoint file of\n            the selected pose2d model. If it is not specified and \"pose2d\" is\n            a model name of metafile, the weights will be loaded from\n            metafile. Defaults to None.\n        device (str, optional): Device to run inference. If None, the\n            available device will be automatically used. Defaults to None.\n        scope (str, optional): The scope of the model. Defaults to \"mmpose\".\n        det_model(str, optional): Config path or alias of detection model.\n            Defaults to None.\n        det_weights(str, optional): Path to the checkpoints of detection\n            model. Defaults to None.\n        det_cat_ids(int or list[int], optional): Category id for\n            detection model. Defaults to None.\n        output_heatmaps (bool, optional): Flag to visualize predicted\n            heatmaps. If set to None, the default setting from the model\n            config will be used. Default is None.\n    \"\"\"\n\n    preprocess_kwargs: set = {\n        'bbox_thr', 'nms_thr', 'bboxes', 'use_oks_tracking', 'tracking_thr',\n        'disable_norm_pose_2d'\n    }\n    forward_kwargs: set = {\n        'merge_results', 'disable_rebase_keypoint', 'pose_based_nms'\n    }\n    visualize_kwargs: set = {\n        'return_vis', 'show', 'wait_time', 'draw_bbox', 'radius', 'thickness',\n        'kpt_thr', 'vis_out_dir', 'skeleton_style', 'draw_heatmap',\n        'black_background', 'num_instances'\n    }\n    postprocess_kwargs: set = {'pred_out_dir', 'return_datasample'}\n\n    def __init__(self,\n                 pose2d: Optional[str] = None,\n                 pose2d_weights: Optional[str] = None,\n                 pose3d: Optional[str] = None,\n                 pose3d_weights: Optional[str] = None,\n                 device: Optional[str] = None,\n                 scope: str = 'mmpose',\n                 det_model: Optional[Union[ModelType, str]] = None,\n                 det_weights: Optional[str] = None,\n                 det_cat_ids: Optional[Union[int, List]] = None,\n                 show_progress: bool = False) -> None:\n\n        self.visualizer = None\n        self.show_progress = show_progress\n        if pose3d is not None:\n            if 'hand3d' in pose3d:\n                self.inferencer = Hand3DInferencer(pose3d, pose3d_weights,\n                                                   device, scope, det_model,\n                                                   det_weights, det_cat_ids,\n                                                   show_progress)\n            else:\n                self.inferencer = Pose3DInferencer(pose3d, pose3d_weights,\n                                                   pose2d, pose2d_weights,\n                                                   device, scope, det_model,\n                                                   det_weights, det_cat_ids,\n                                                   show_progress)\n        elif pose2d is not None:\n            self.inferencer = Pose2DInferencer(pose2d, pose2d_weights, device,\n                                               scope, det_model, det_weights,\n                                               det_cat_ids, show_progress)\n        else:\n            raise ValueError('Either 2d or 3d pose estimation algorithm '\n                             'should be provided.')\n\n    def preprocess(self, inputs: InputsType, batch_size: int = 1, **kwargs):\n        \"\"\"Process the inputs into a model-feedable format.\n\n        Args:\n            inputs (InputsType): Inputs given by user.\n            batch_size (int): batch size. Defaults to 1.\n\n        Yields:\n            Any: Data processed by the ``pipeline`` and ``collate_fn``.\n            List[str or np.ndarray]: List of original inputs in the batch\n        \"\"\"\n        for data in self.inferencer.preprocess(inputs, batch_size, **kwargs):\n            yield data\n\n    @torch.no_grad()\n    def forward(self, inputs: InputType, **forward_kwargs) -> PredType:\n        \"\"\"Forward the inputs to the model.\n\n        Args:\n            inputs (InputsType): The inputs to be forwarded.\n\n        Returns:\n            Dict: The prediction results. Possibly with keys \"pose2d\".\n        \"\"\"\n        return self.inferencer.forward(inputs, **forward_kwargs)\n\n    def __call__(\n        self,\n        inputs: InputsType,\n        return_datasamples: bool = False,\n        batch_size: int = 1,\n        out_dir: Optional[str] = None,\n        **kwargs,\n    ) -> dict:\n        \"\"\"Call the inferencer.\n\n        Args:\n            inputs (InputsType): Inputs for the inferencer.\n            return_datasamples (bool): Whether to return results as\n                :obj:`BaseDataElement`. Defaults to False.\n            batch_size (int): Batch size. Defaults to 1.\n            out_dir (str, optional): directory to save visualization\n                results and predictions. Will be overoden if vis_out_dir or\n                pred_out_dir are given. Defaults to None\n            **kwargs: Key words arguments passed to :meth:`preprocess`,\n                :meth:`forward`, :meth:`visualize` and :meth:`postprocess`.\n                Each key in kwargs should be in the corresponding set of\n                ``preprocess_kwargs``, ``forward_kwargs``,\n                ``visualize_kwargs`` and ``postprocess_kwargs``.\n\n        Returns:\n            dict: Inference and visualization results.\n        \"\"\"\n        if out_dir is not None:\n            if 'vis_out_dir' not in kwargs:\n                kwargs['vis_out_dir'] = f'{out_dir}/visualizations'\n            if 'pred_out_dir' not in kwargs:\n                kwargs['pred_out_dir'] = f'{out_dir}/predictions'\n\n        kwargs = {\n            key: value\n            for key, value in kwargs.items()\n            if key in set.union(self.inferencer.preprocess_kwargs,\n                                self.inferencer.forward_kwargs,\n                                self.inferencer.visualize_kwargs,\n                                self.inferencer.postprocess_kwargs)\n        }\n        (\n            preprocess_kwargs,\n            forward_kwargs,\n            visualize_kwargs,\n            postprocess_kwargs,\n        ) = self._dispatch_kwargs(**kwargs)\n\n        self.inferencer.update_model_visualizer_settings(**kwargs)\n\n        # preprocessing\n        if isinstance(inputs, str) and inputs.startswith('webcam'):\n            inputs = self.inferencer._get_webcam_inputs(inputs)\n            batch_size = 1\n            if not visualize_kwargs.get('show', False):\n                warnings.warn('The display mode is closed when using webcam '\n                              'input. It will be turned on automatically.')\n            visualize_kwargs['show'] = True\n        else:\n            inputs = self.inferencer._inputs_to_list(inputs)\n        self._video_input = self.inferencer._video_input\n        if self._video_input:\n            self.video_info = self.inferencer.video_info\n\n        inputs = self.preprocess(\n            inputs, batch_size=batch_size, **preprocess_kwargs)\n\n        # forward\n        if 'bbox_thr' in self.inferencer.forward_kwargs:\n            forward_kwargs['bbox_thr'] = preprocess_kwargs.get('bbox_thr', -1)\n\n        preds = []\n\n        for proc_inputs, ori_inputs in (track(inputs, description='Inference')\n                                        if self.show_progress else inputs):\n            preds = self.forward(proc_inputs, **forward_kwargs)\n\n            visualization = self.visualize(ori_inputs, preds,\n                                           **visualize_kwargs)\n            results = self.postprocess(\n                preds,\n                visualization,\n                return_datasamples=return_datasamples,\n                **postprocess_kwargs)\n            yield results\n\n        if self._video_input:\n            self._finalize_video_processing(\n                postprocess_kwargs.get('pred_out_dir', ''))\n\n    def visualize(self, inputs: InputsType, preds: PredType,\n                  **kwargs) -> List[np.ndarray]:\n        \"\"\"Visualize predictions.\n\n        Args:\n            inputs (list): Inputs preprocessed by :meth:`_inputs_to_list`.\n            preds (Any): Predictions of the model.\n            return_vis (bool): Whether to return images with predicted results.\n            show (bool): Whether to display the image in a popup window.\n                Defaults to False.\n            show_interval (int): The interval of show (s). Defaults to 0\n            radius (int): Keypoint radius for visualization. Defaults to 3\n            thickness (int): Link thickness for visualization. Defaults to 1\n            kpt_thr (float): The threshold to visualize the keypoints.\n                Defaults to 0.3\n            vis_out_dir (str, optional): directory to save visualization\n                results w/o predictions. If left as empty, no file will\n                be saved. Defaults to ''.\n\n        Returns:\n            List[np.ndarray]: Visualization results.\n        \"\"\"\n        window_name = ''\n        if self.inferencer._video_input:\n            window_name = self.inferencer.video_info['name']\n\n        return self.inferencer.visualize(\n            inputs, preds, window_name=window_name, **kwargs)\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}