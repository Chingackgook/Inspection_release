{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/EverydayWechat",
    "API_Calls": [
        {
            "Name": "auto_reply",
            "Description": "用于实现微信好友和群聊的智能自动回复功能：当用户收到微信好友发送的私聊消息时，系统会调用该接口获取AI机器人的智能回复内容并自动发送给好友",
            "Code": "# -*- coding: utf-8 -*-\n\"\"\"\nProject: EverydayWechat-Github\nCreator: DoubleThunder\nCreate time: 2019-07-12 23:07\nIntroduction: 处理好友消息内容\n\"\"\"\n\nimport time\nimport random\nimport itchat\nfrom everyday_wechat.utils import config\nfrom everyday_wechat.utils.data_collection import (\n    get_bot_info,\n)\nfrom everyday_wechat.utils.common import (\n    FILEHELPER,\n)\n\n__all__ = ['handle_friend']\n\n\ndef handle_friend(msg):\n    \"\"\" 处理好友信息 \"\"\"\n    try:\n\n        # 自己通过手机微信发送给别人的消息(文件传输助手除外)不作处理。\n        if msg['FromUserName'] == config.get('wechat_uuid') and msg['ToUserName'] != FILEHELPER:\n            return\n\n        conf = config.get('auto_reply_info')\n        if not conf.get('is_auto_reply'):\n            return\n        # 获取发送者的用户id\n        uuid = FILEHELPER if msg['ToUserName'] == FILEHELPER else msg['FromUserName']\n        is_all = conf.get('is_auto_reply_all')\n        auto_uuids = conf.get('auto_reply_black_uuids') if is_all else conf.get('auto_reply_white_uuids')\n        # 开启回复所有人，当用户是黑名单，不回复消息\n        if is_all and uuid in auto_uuids:\n            return\n\n        # 关闭回复所有人，当用户不是白名单，不回复消息\n        if not is_all and uuid not in auto_uuids:\n            return\n\n        receive_text = msg.text  # 好友发送来的消息内容\n        # 好友叫啥，用于打印\n        nick_name = FILEHELPER if uuid == FILEHELPER else msg.user.nickName\n        print('\\n{}发来信息：{}'.format(nick_name, receive_text))\n        reply_text = get_bot_info(receive_text, uuid)  # 获取自动回复\n        if reply_text:  # 如内容不为空，回复消息\n            time.sleep(random.randint(1, 2))  # 休眠一秒，保安全。想更快的，可以直接注释。\n\n            prefix = conf.get('auto_reply_prefix', '')  # 前缀\n            if prefix:\n                reply_text = '{}{}'.format(prefix, reply_text)\n\n            suffix = conf.get('auto_reply_suffix', '')  # 后缀\n            if suffix:\n                reply_text = '{}{}'.format(reply_text, suffix)\n\n            itchat.send(reply_text, toUserName=uuid)\n            print('回复{}：{}'.format(nick_name, reply_text))\n        else:\n            print('自动回复失败\\n')\n    except Exception as exception:\n        print(str(exception))\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/EverydayWechat/everyday_wechat/utils/friend_helper.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "function_get_bot_info",
            "Description": "get_bot_info 接口是AI机器人回复调度中心，它通过读取配置文件中的 bot_channel 参数来动态选择对应的AI机器人服务（如青云客、图灵、思知等），然后使用 importlib 动态导入相应的机器人模块并调用其 get_auto_reply 方法，最终通过 HTTP 请求向第三方AI服务发送用户消息并返回智能回复内容，实现了多机器人渠道的统一管理和灵活切换功能。",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/EverydayWechat/everyday_wechat/utils/data_collection.py",
            "Implementation": "# coding=utf-8\n\"\"\"\n获取各种请求的调度管理中心\n\"\"\"\nimport importlib\nimport re\nfrom datetime import datetime\nfrom datetime import timedelta\n\n# from everyday_wechat.control.weather.rtweather import get_today_weather\nfrom everyday_wechat.control.weather.sojson import get_sojson_weather\nfrom everyday_wechat.utils.common import (\n    get_constellation_name,\n)\nfrom everyday_wechat.utils import config\nfrom everyday_wechat.control.horoscope.xzw_horescope import get_today_horoscope\n# from everyday_wechat.control.calendar.sojson_calendar import get_sojson_calendar\nfrom everyday_wechat.control.calendar.rt_calendar import get_rtcalendar\n\n__all__ = [\n    'get_dictum_info', 'get_weather_info', 'get_bot_info',\n    'get_diff_time', 'get_constellation_info', 'get_calendar_info',\n    'DICTUM_NAME_DICT', 'BOT_NAME_DICT'\n]\n\nDICTUM_NAME_DICT = {\n    1: 'wufazhuce', 2: 'acib', 3: 'lovelive', 4: 'hitokoto',\n    5: 'rtjokes', 6: 'juzimi', 7: 'caihongpi'\n}\nBOT_NAME_DICT = {\n    1: 'tuling123', 2: 'yigeai', 3: 'qingyunke', 4: 'qq_nlpchat',\n    5: 'tian_robot', 6: 'ruyiai', 7: 'ownthink_robot'\n}\n# 用于星座的正则表达式\nBIRTHDAY_COMPILE = re.compile(r'\\-?(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])$')\n\n\ndef get_dictum_info(channel):\n    \"\"\"\n    获取每日一句。\n    :return:str\n    \"\"\"\n    if not channel:\n        return None\n    source = DICTUM_NAME_DICT.get(channel, '')\n    if source:\n        addon = importlib.import_module('everyday_wechat.control.onewords.' + source, __package__)\n        dictum = addon.get_one_words()\n        # print(dictum)\n        return dictum\n    return None\n\n\ndef get_weather_info(cityname, is_tomorrow=False):\n    \"\"\"\n    获取天气\n    :param cityname:str,城市名称\n    :return: str,天气情况\n    \"\"\"\n    if not cityname:\n        return\n    # return get_today_weather(cityname)\n    return get_sojson_weather(cityname, is_tomorrow)\n\n\ndef get_bot_info(message, userId=''):\n    \"\"\"\n    跟机器人互动\n    # 优先获取图灵机器人API的回复，但失效时，会使用青云客智能聊天机器人API(过时)\n    :param message:str, 发送的话\n    :param userId: str, 好友的uid，作为请求的唯一标识。\n    :return:str, 机器人回复的话。\n    \"\"\"\n\n    channel = config.get('auto_reply_info').get('bot_channel', 7)\n    source = BOT_NAME_DICT.get(channel, 'ownthink_robot')\n    # print(source)\n    if source:\n        addon = importlib.import_module('everyday_wechat.control.bot.' + source, __package__)\n        reply_msg = addon.get_auto_reply(message, userId)\n        return reply_msg\n    # reply_msg = get_tuling123(message)\n    # if not reply_msg:\n    #     # reply_msg = get_qingyunke(message)\n    #     reply_msg = get_yigeai(message)\n\n    return None\n\n\ndef get_diff_time(start_date, start_msg=''):\n    \"\"\"\n    # 在一起，一共多少天了。\n    :param start_date:str,日期\n    :return: str,eg（宝贝这是我们在一起的第 111 天。）\n    \"\"\"\n    if not start_date:\n        return None\n    rdate = r'^[12]\\d{3}[ \\/\\-](?:0?[1-9]|1[012])[ \\/\\-](?:0?[1-9]|[12][0-9]|3[01])$'\n    start_date = start_date.strip()\n    if not re.search(rdate, start_date):\n        print('日期填写出错..')\n        return\n    start_datetime = datetime.strptime(start_date, '%Y-%m-%d')\n    day_delta = (datetime.now() - start_datetime).days + 1\n    if start_msg and start_msg.count('{}') == 1:\n        delta_msg = start_msg.format(day_delta)\n    else:\n        delta_msg = '宝贝这是我们在一起的第 {} 天。'.format(day_delta)\n    return delta_msg\n\n\ndef get_constellation_info(birthday_str, is_tomorrow=False):\n    \"\"\"\n    获取星座运势\n    :param birthday_str:  \"10-12\" 或  \"1980-01-08\" 或 星座名\n    :return:\n    \"\"\"\n    if not birthday_str:\n        return\n    const_name = get_constellation_name(birthday_str)\n    if not const_name:\n        print('星座名填写错误')\n        return\n    return get_today_horoscope(const_name, is_tomorrow)\n\n\ndef get_calendar_info(calendar=True, is_tomorrow=False, _date=''):\n    \"\"\" 获取万年历 \"\"\"\n    if not calendar:\n        return None\n    if not is_tomorrow:\n        date = datetime.now().strftime('%Y%m%d')\n    else:\n        date = (datetime.now() + timedelta(days=1)).strftime('%Y%m%d')\n    return get_rtcalendar(date)\n\n    # else:\n    #     time_now = datetime.now()\n    #     week = WEEK_DICT[time_now.strftime('%A')]\n    #     date = time_now.strftime('%Y-%m-%d')\n    #     return '{} {}'.format(date, week)\n\n\nif __name__ == '__main__':\n    config.init()\n    text = 'are you ok'\n    reply_msg = get_bot_info(text)\n    print(reply_msg)\n    pass\n",
            "Examples": [
                "# -*- coding: utf-8 -*-\n\"\"\"\nEverydayWechat 生成回答功能测试文件 - 简洁版\n测试核心的AI机器人回复和内容生成功能\n\"\"\"\n\nimport sys\nimport os\nfrom datetime import datetime\n\n# 添加项目路径到系统路径\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\ndef test_bot_reply():\n    \"\"\"测试AI机器人回复功能\"\"\"\n    print(\"=\" * 40)\n    print(\"测试AI机器人回复功能\")\n    print(\"=\" * 40)\n    \n    try:\n        from everyday_wechat.utils.data_collection import get_bot_info, BOT_NAME_DICT\n        from everyday_wechat.utils import config\n        \n        # 检查当前配置\n        bot_channel = config.get('auto_reply_info').get('bot_channel', 7)\n        source = BOT_NAME_DICT.get(bot_channel, 'ownthink_robot')\n        print(f\"当前配置的机器人渠道: {bot_channel}\")\n        print(f\"对应的机器人模块: {source}\")\n        \n        # 测试青云客机器人（当前配置的机器人）\n        print(f\"\\n测试{source}机器人:\")\n        test_messages = [\n            \"你好\",\n            \"今天天气怎么样？\", \n            \"讲个笑话\",\n            \"你是谁？\",\n            \"现在几点了？\"\n        ]\n        \n        for message in test_messages:\n            print(f\"\\n测试消息: {message}\")\n            try:\n                reply = get_bot_info(message, \"test_user_001\")\n                if reply:\n                    print(f\"机器人回复: {reply}\")\n                else:\n                    print(\"机器人回复: 无回复\")\n            except Exception as e:\n                print(f\"机器人回复失败: {e}\")\n                \n    except Exception as e:\n        print(f\"测试AI机器人功能失败: {e}\")\n        import traceback\n        traceback.print_exc()\n\n\ndef main():\n    \"\"\"主测试函数\"\"\"\n    print(\"EverydayWechat 生成回答功能测试 - 简洁版\")\n    print(\"开始时间:\", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n    \n    # 测试核心功能\n    test_bot_reply()\n\nif __name__ == '__main__':\n    main()\n\n"
            ]
        }
    ]
}