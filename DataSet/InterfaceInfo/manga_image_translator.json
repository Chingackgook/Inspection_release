{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/manga-image-translator",
    "API_Calls": [
        {
            "Name": "call_MangaTranslatorLocal",
            "Description": "call MangaTranslatorLocal to translate the text in the image",
            "Code": "import os\nimport sys\nimport asyncio\nimport logging\nfrom argparse import Namespace\n\nfrom manga_translator import Config\nfrom manga_translator.args import parser, reparse\nfrom .manga_translator import (\n    set_main_logger, load_dictionary, apply_dictionary,\n)\nfrom .args import parser\nfrom .utils import (\n    BASE_PATH,\n    init_logging,\n    get_logger,\n    set_log_level,\n    natural_sort,\n)\n\n# TODO: Dynamic imports to reduce ram usage in web(-server) mode. Will require dealing with args.py imports.\n\nasync def dispatch(args: Namespace):\n    args_dict = vars(args)\n\n    logger.info(f'Running in {args.mode} mode')\n\n    if args.mode == 'local':\n        if not args.input:\n            raise Exception('No input image was supplied. Use -i <image_path>')\n        from manga_translator.mode.local import MangaTranslatorLocal\n        translator = MangaTranslatorLocal(args_dict)\n\n        # Load pre-translation and post-translation dictionaries\n        pre_dict = load_dictionary(args.pre_dict)\n        post_dict = load_dictionary(args.post_dict)\n\n        if len(args.input) == 1 and os.path.isfile(args.input[0]):\n            dest = os.path.join(BASE_PATH, 'result/final.png')\n            args.overwrite = True # Do overwrite result/final.png file\n\n            # Apply pre-translation dictionaries\n            await translator.translate_path(args.input[0], dest, args_dict)\n            for textline in translator.textlines:\n                textline.text = apply_dictionary(textline.text, pre_dict)\n                logger.info(f'Pre-translation dictionary applied: {textline.text}')\n\n            # Apply post-translation dictionaries\n            for textline in translator.textlines:\n                textline.translation = apply_dictionary(textline.translation, post_dict)\n                logger.info(f'Post-translation dictionary applied: {textline.translation}')\n\n        else: # batch\n            dest = args.dest\n            for path in natural_sort(args.input):\n                    # Apply pre-translation dictionaries\n                await translator.translate_path(path, dest, args_dict)\n                for textline in translator.textlines:\n                    textline.text = apply_dictionary(textline.text, pre_dict)\n                    logger.info(f'Pre-translation dictionary applied: {textline.text}')\n\n                    # Apply post-translation dictionaries\n                for textline in translator.textlines:\n                    textline.translation = apply_dictionary(textline.translation, post_dict)\n                    logger.info(f'Post-translation dictionary applied: {textline.translation}')\n\n    elif args.mode == 'ws':\n        from manga_translator.mode.ws import MangaTranslatorWS\n        translator = MangaTranslatorWS(args_dict)\n        await translator.listen(args_dict)\n\n    elif args.mode == 'shared':\n        from manga_translator.mode.share import MangaShare\n        translator = MangaShare(args_dict)\n        await translator.listen(args_dict)\n    elif args.mode == 'config-help':\n        import json\n        config = Config.schema()\n        print(json.dumps(config, indent=2))\n\n\n\nif __name__ == '__main__':\n    args = None\n    init_logging()\n    try:\n        args, unknown = parser.parse_known_args()\n        args = Namespace(**{**vars(args), **vars(reparse(unknown))})\n        set_log_level(level=logging.DEBUG if args.verbose else logging.INFO)\n        logger = get_logger(args.mode)\n        set_main_logger(logger)\n        if args.mode != 'web':\n            logger.debug(args)\n\n        asyncio.run(dispatch(args))\n    except KeyboardInterrupt:\n        print('\\nTranslation cancelled by user.')\n        sys.exit(0)\n    except asyncio.CancelledError:\n        print('\\nTranslation cancelled by user.')\n        sys.exit(0)\n    except Exception as e:\n        logger.error(f'{e.__class__.__name__}: {e}',\n                     exc_info=e if args and args.verbose else None)\n\n\n\n'''\n# Some additional info for the argparse module used in the code\n\nimport argparse\nimport os\nfrom urllib.parse import unquote\n\nfrom .detection import DETECTORS\nfrom .ocr import OCRS\nfrom .inpainting import INPAINTERS\nfrom .translators import VALID_LANGUAGES, TRANSLATORS, TranslatorChain\nfrom .upscaling import UPSCALERS\nfrom .colorization import COLORIZERS\nfrom .save import OUTPUT_FORMATS\n\ndef url_decode(s):\n    s = unquote(s)\n    if s.startswith('file:///'):\n        s = s[len('file://'):]\n    return s\n\n# Additional argparse types\ndef path(string):\n    if not string:\n        return ''\n    s = url_decode(os.path.expanduser(string))\n    if not os.path.exists(s):\n        raise argparse.ArgumentTypeError(f'No such file or directory: \"{string}\"')\n    return s\n\ndef file_path(string):\n    if not string:\n        return ''\n    s = url_decode(os.path.expanduser(string))\n    if not os.path.exists(s):\n        raise argparse.ArgumentTypeError(f'No such file: \"{string}\"')\n    return s\n\ndef dir_path(string):\n    if not string:\n        return ''\n    s = url_decode(os.path.expanduser(string))\n    if not os.path.exists(s):\n        raise argparse.ArgumentTypeError(f'No such directory: \"{string}\"')\n    return s\n\n# def choice_chain(choices):\n#     \"\"\"Argument type for string chains from choices separated by ':'. Example: 'choice1:choice2:choice3'\"\"\"\n#     def _func(string):\n#         if choices is not None:\n#             for s in string.split(':') or ['']:\n#                 if s not in choices:\n#                     raise argparse.ArgumentTypeError(f'Invalid choice: %s (choose from %s)' % (s, ', '.join(map(repr, choices))))\n#         return string\n#     return _func\n\nclass HelpFormatter(argparse.HelpFormatter):\n    INDENT_INCREMENT = 2\n    MAX_HELP_POSITION = 24\n    WIDTH = None\n\n    def __init__(self, prog: str, indent_increment: int = 2, max_help_position: int = 24, width: int = None):\n        super().__init__(prog, self.INDENT_INCREMENT, self.MAX_HELP_POSITION, self.WIDTH)\n\n    def _format_action_invocation(self, action: argparse.Action) -> str:\n        if action.option_strings:\n\n            # if the Optional doesn't take a value, format is:\n            #    -s, --long\n            if action.nargs == 0:\n                return ', '.join(action.option_strings)\n\n            # if the Optional takes a value, format is:\n            #    -s, --long ARGS\n            else:\n                default = self._get_default_metavar_for_optional(action)\n                args_string = self._format_args(action, default)\n                return ', '.join(action.option_strings) + ' ' + args_string\n        else:\n            return super()._format_action_invocation(action)\n\ndef general_parser(g_parser):\n    g_parser.add_argument('-v', '--verbose', action='store_true',\n                        help='Print debug info and save intermediate images in result folder')\n    g_parser.add_argument('--attempts', default=0, type=int,\n                        help='Retry attempts on encountered error. -1 means infinite times.')\n    g_parser.add_argument('--ignore-errors', action='store_true', help='Skip image on encountered error.')\n    g_parser.add_argument('--model-dir', default=None, type=dir_path,\n                        help='Model directory (by default ./models in project root)')\n    g = g_parser.add_mutually_exclusive_group()\n    g.add_argument('--use-gpu', action='store_true', help='Turn on/off gpu (auto switch between mps and cuda)')\n    g.add_argument('--use-gpu-limited', action='store_true', help='Turn on/off gpu (excluding offline translator)')\n    g_parser.add_argument('--font-path', default='', type=file_path, help='Path to font file')\n    g_parser.add_argument('--pre-dict', default=None, type=file_path, help='Path to the pre-translation dictionary file')\n    g_parser.add_argument('--post-dict', default=None, type=file_path,\n                        help='Path to the post-translation dictionary file')\n    g_parser.add_argument('--kernel-size', default=3, type=int,\n                        help='Set the convolution kernel size of the text erasure area to completely clean up text residues')\n    g_parser.add_argument('--context-size', default=0, type=int, help='Pages of context are needed for translating the current page')\n    g_parser.add_argument('--batch-size', default=1, type=int,\n                        help='Number of images to process in each batch for translation. Default is 1 (no batching)')\n    g_parser.add_argument('--batch-concurrent', action='store_true',\n                        help='Use concurrent mode for batch translation - process each image separately instead of merging into large batches. Helps prevent model output truncation and hallucination.')\n    g_parser.add_argument('--disable-memory-optimization', action='store_true',\n                        help='Disable automatic memory optimization during processing')\n\n\ndef reparse(arr: list):\n    p = argparse.ArgumentParser(prog='manga_translator',\n                                     description='Seamlessly translate mangas into a chosen language',\n                                     formatter_class=HelpFormatter)\n    general_parser(p)\n    return p.parse_args(arr)\n\nparser = argparse.ArgumentParser(prog='manga_translator', description='Seamlessly translate mangas into a chosen language', formatter_class=HelpFormatter)\ngeneral_parser(parser)\nsubparsers = parser.add_subparsers(dest='mode', required=True, help='Mode of operation')\n\n# Batch mode\nparser_batch = subparsers.add_parser('local', help='Run in batch translation mode')\nparser_batch.add_argument('-i', '--input', required=True, type=path, nargs='+', help='Path to an image folder')\nparser_batch.add_argument('-o', '--dest', default='', type=str, help='Path to the destination folder for translated images')\nparser_batch.add_argument('-f', '--format', default=None, choices=OUTPUT_FORMATS, help='Output format of the translation.')\nparser_batch.add_argument('--overwrite', action='store_true', help='Overwrite already translated images')\nparser_batch.add_argument('--skip-no-text', action='store_true', help='Skip image without text (Will not be saved).')\nparser_batch.add_argument('--use-mtpe', action='store_true', help='Turn on/off machine translation post editing (MTPE) on the command line (works only on linux right now)')\ng_batch = parser_batch.add_mutually_exclusive_group()\ng_batch.add_argument('--save-text', action='store_true', help='Save extracted text and translations into a text file.')\ng_batch.add_argument('--load-text', action='store_true', help='Load extracted text and translations from a text file.')\ng_batch.add_argument('--save-text-file', default='', type=str, help='Like --save-text but with a specified file path.')\nparser_batch.add_argument('--prep-manual', action='store_true', help='Prepare for manual typesetting by outputting blank, inpainted images, plus copies of the original for reference')\nparser_batch.add_argument('--save-quality', default=100, type=int, help='Quality of saved JPEG image, range from 0 to 100 with 100 being best')\nparser_batch.add_argument('--config-file', default=None, type=str, help='path to the config file')\n\n'''",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/manga-image-translator/manga_translator/__main__.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "MangaTranslatorLocal",
            "Description": "MangaTranslatorLocal impl",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/manga-image-translator/manga_translator/mode/local.py",
            "Implementation": "import json\nimport os\nimport gc\nimport copy\nfrom typing import Union, List\nimport time  \n\nfrom PIL import Image\nimport psutil\n\nfrom manga_translator import MangaTranslator, Context, TranslationInterrupt, Config\nfrom ..save import save_result\nfrom ..translators import (\n    LanguageUnsupportedException,\n    dispatch as dispatch_translation,\n)\nfrom ..utils import natural_sort, replace_prefix, get_color_name, rgb2hex, get_logger\n\n# 使用专用的local logger\nlogger = get_logger('local')\n\ndef safe_get_memory_info():\n    \"\"\"安全获取内存信息，失败时返回默认值\"\"\"\n    try:\n        memory = psutil.virtual_memory()\n        return memory.percent, memory.available // (1024 * 1024)  # 可用内存MB\n    except Exception as e:\n        logger.warning(f'Unable to get memory info: {e}')\n        return 95.0, 100  # 假设高内存使用率，低可用内存\n\ndef force_cleanup():\n    \"\"\"强制内存清理\"\"\"\n    logger.debug('Performing force memory cleanup...')\n    import gc\n    import torch\n    \n    # Python垃圾回收    \n    collected = gc.collect()\n    \n    # PyTorch缓存清理   \n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()\n        torch.cuda.synchronize()\n    \n    # 尝试清理更多内存  \n    try:\n        import ctypes\n        ctypes.windll.kernel32.SetProcessWorkingSetSize(-1, -1, -1)\n    except:\n        pass\n\nclass MangaTranslatorLocal(MangaTranslator):\n    def __init__(self, params: dict = None):\n        super().__init__(params)\n        self.textlines = []\n        self.attempts = params.get('attempts', None)\n        self.skip_no_text = params.get('skip_no_text', False)\n        self.text_output_file = params.get('text_output_file', None)\n        self.save_quality = params.get('save_quality', None)\n        self.text_regions = params.get('text_regions', None)\n        self.save_text_file = params.get('save_text_file', None)\n        self.save_text = params.get('save_text', None)\n        self.prep_manual = params.get('prep_manual', None)\n        self.batch_size = params.get('batch_size', 1)\n        self.disable_memory_optimization = params.get('disable_memory_optimization', False)\n\n    async def translate_path(self, path: str, dest: str = None, params: dict[str, Union[int, str]] = None):\n        \"\"\"\n        Translates an image or folder (recursively) specified through the path.\n        \"\"\"\n        if not os.path.exists(path):\n            raise FileNotFoundError(path)\n        path = os.path.abspath(os.path.expanduser(path))\n        dest = os.path.abspath(os.path.expanduser(dest)) if dest else ''\n        params = params or {}\n        config_file_path = params.get(\"config_file\", None)\n\n        if config_file_path:\n            try:\n                with open(config_file_path, 'r') as file:\n                    config_content = file.read()\n            except Exception as e:\n                print(\"Couldnt read file\")\n                raise e\n            config_extension = os.path.splitext(config_file_path)[1].lower()\n\n            try:\n                if config_extension == \".toml\":\n                    import tomllib\n                    config_dict = tomllib.loads(config_content)\n                elif config_extension == \".json\":\n                    config_dict = json.loads(config_content)\n                else:\n                    raise ValueError(\"Unsupported configuration file format\")\n            except Exception as e:\n                print(\"Failed to load configuration file\")\n                raise e\n            config = Config(**config_dict)\n        else:\n            config = Config()\n        # Handle format\n        file_ext = params.get('format')\n        if params.get('save_quality', 100) < 100:\n            if not params.get('format'):\n                file_ext = 'jpg'\n            elif params.get('format') != 'jpg':\n                raise ValueError('--save-quality of lower than 100 is only supported for .jpg files')\n\n        if os.path.isfile(path):\n            # Determine destination file path\n            if not dest:\n                # Use the same folder as the source\n                p, ext = os.path.splitext(path)\n                _dest = f'{p}-translated.{file_ext or ext[1:]}'\n            elif not os.path.basename(dest):\n                p, ext = os.path.splitext(os.path.basename(path))\n                # If the folders differ use the original filename from the source\n                if os.path.dirname(path) != dest:\n                    _dest = os.path.join(dest, f'{p}.{file_ext or ext[1:]}')\n                else:\n                    _dest = os.path.join(dest, f'{p}-translated.{file_ext or ext[1:]}')\n            else:\n                p, ext = os.path.splitext(dest)\n                _dest = f'{p}.{file_ext or ext[1:]}'\n            await self.translate_file(path, _dest, params,config)\n\n        elif os.path.isdir(path):\n            # Determine destination folder path\n            if path[-1] == '\\\\' or path[-1] == '/':\n                path = path[:-1]\n            _dest = dest or path + '-translated'\n            if os.path.exists(_dest) and not os.path.isdir(_dest):\n                raise FileExistsError(_dest)\n\n            # 检查是否使用批量处理\n            if self.batch_size > 1:\n                await self._translate_folder_batch(path, _dest, params, config, file_ext)\n            else:\n                # 原有的逐个处理方式\n                start_time = time.time()  # 记录开始时间\n                translated_count = 0\n                for root, subdirs, files in os.walk(path):\n                    files = natural_sort(files)\n                    dest_root = replace_prefix(root, path, _dest)\n                    os.makedirs(dest_root, exist_ok=True)\n                    for f in files:\n                        if f.lower() == '.thumb':\n                            continue\n\n                        file_path = os.path.join(root, f)\n                        output_dest = replace_prefix(file_path, path, _dest)\n                        p, ext = os.path.splitext(output_dest)\n                        output_dest = f'{p}.{file_ext or ext[1:]}'\n                        try:\n                            if await self.translate_file(file_path, output_dest, params, config):\n                                translated_count += 1\n                        except Exception as e:\n                            logger.error(e)\n                            raise e\n                \n                # 计算总耗时\n                total_time = time.time() - start_time\n                \n                if translated_count == 0:\n                    logger.info('No further untranslated files found. Use --overwrite to write over existing translations.')\n                else:\n                    # 格式化时间显示\n                    if total_time >= 3600:  \n                        time_str = f\"{total_time/3600:.1f} hours\"\n                    elif total_time >= 60:  \n                        time_str = f\"{total_time/60:.1f} minutes\"\n                    else:  \n                        time_str = f\"{total_time:.1f} seconds\"\n                    \n                    logger.info(f'Done. Translated {translated_count} image{\"\" if translated_count == 1 else \"s\"} in {time_str}')\n                    logger.info(f'Results saved to: \"{_dest}\"')\n\n    async def translate_file(self, path: str, dest: str, params: dict, config: Config):\n        if not params.get('overwrite') and os.path.exists(dest):\n            logger.info(\n                f'Skipping as already translated: \"{dest}\". Use --overwrite to overwrite existing translations.')\n            await self._report_progress('saved', True)\n            return True\n\n        logger.info(f'Translating: \"{path}\"')\n\n        # Turn dict to context to make values also accessible through params.<property>\n        params = params or {}\n        ctx = Context(**params)\n\n        attempts = 0\n        while self.attempts == -1 or attempts < self.attempts + 1:\n            if attempts > 0:\n                logger.info(f'Retrying translation! Attempt {attempts}'\n                            + (f' of {self.attempts}' if self.attempts != -1 else ''))\n            try:\n                return await self._translate_file(path, dest, config, ctx)\n\n            except TranslationInterrupt:\n                break\n            except Exception as e:\n                if isinstance(e, LanguageUnsupportedException):\n                    await self._report_progress('error-lang', True)\n                else:\n                    await self._report_progress('error', True)\n                if not self.ignore_errors and not (self.attempts == -1 or attempts < self.attempts):\n                    raise\n                else:\n                    logger.error(f'{e.__class__.__name__}: {e}',\n                                 exc_info=e if self.verbose else None)\n            attempts += 1\n        return False\n\n    async def _translate_file(self, path: str, dest: str, config: Config, ctx: Context) -> bool:\n        if path.endswith('.txt'):\n            with open(path, 'r') as f:\n                queries = f.read().split('\\n')\n            translated_sentences = \\\n                await dispatch_translation(config.translator.translator_gen, queries, self.use_mtpe, ctx,\n                                           'cpu' if self._gpu_limited_memory else self.device)\n            p, ext = os.path.splitext(dest)\n            if ext != '.txt':\n                dest = p + '.txt'\n            logger.info(f'Saving \"{dest}\"')\n            with open(dest, 'w') as f:\n                f.write('\\n'.join(translated_sentences))\n            return True\n\n        # TODO: Add .gif handler\n\n        else:  # Treat as image\n            try:\n                img = Image.open(path)\n                img.verify()\n                img = Image.open(path)\n            except Exception:\n                logger.warn(f'Failed to open image: {path}')\n                return False\n\n            # 提取文件名作为image_name参数，用于调试文件夹命名\n            image_name = os.path.basename(path)\n            ctx = await self.translate(img, config, image_name)\n            result = ctx.result\n\n            # TODO\n            # Proper way to use the config but for now juste pass what we miss here ton ctx\n            # Because old methods are still using for example ctx.gimp_font\n            # Not done before because we change the ctx few lines above\n            ctx.gimp_font = config.render.gimp_font\n\n            # Save result\n            if self.skip_no_text and not ctx.text_regions:\n                logger.debug('Not saving due to --skip-no-text')\n                return True\n            if result:\n                logger.info(f'Saving \"{dest}\"')\n                ctx.save_quality = self.save_quality\n                save_result(result, dest, ctx)\n                await self._report_progress('saved', True)\n\n                if self.save_text or self.save_text_file or self.prep_manual:\n                    if self.prep_manual:\n                        # Save original image next to translated\n                        p, ext = os.path.splitext(dest)\n                        img_filename = p + '-orig' + ext\n                        img_path = os.path.join(os.path.dirname(dest), img_filename)\n                        img.save(img_path, quality=self.save_quality)\n                    if self.text_regions:\n                        self._save_text_to_file(path, ctx)\n                return True\n        return False\n\n    def _save_text_to_file(self, image_path: str, ctx: Context):\n        cached_colors = []\n\n        def identify_colors(fg_rgb: List[int]):\n            idx = 0\n            for rgb, _ in cached_colors:\n                # If similar color already saved\n                if abs(rgb[0] - fg_rgb[0]) + abs(rgb[1] - fg_rgb[1]) + abs(rgb[2] - fg_rgb[2]) < 50:\n                    break\n                else:\n                    idx += 1\n            else:\n                cached_colors.append((fg_rgb, get_color_name(fg_rgb)))\n            return idx + 1, cached_colors[idx][1]\n\n        s = f'\\n[{image_path}]\\n'\n        for i, region in enumerate(ctx.text_regions):\n            fore, back = region.get_font_colors()\n            color_id, color_name = identify_colors(fore)\n\n            s += f'\\n-- {i + 1} --\\n'\n            s += f'color: #{color_id}: {color_name} (fg, bg: {rgb2hex(*fore)} {rgb2hex(*back)})\\n'\n            s += f'text:  {region.text}\\n'\n            s += f'trans: {region.translation}\\n'\n            for line in region.lines:\n                s += f'coords: {list(line.ravel())}\\n'\n        s += '\\n'\n\n        text_output_file = self.text_output_file\n        if not text_output_file:\n            text_output_file = os.path.splitext(image_path)[0] + '_translations.txt'\n\n        with open(text_output_file, 'a', encoding='utf-8') as f:\n            f.write(s)\n\n    async def _translate_folder_batch(self, path: str, dest: str, params: dict, config: Config, file_ext: str):\n        \"\"\"使用批量处理方式翻译文件夹中的图片\"\"\"\n        \n        start_time = time.time()  # 记录开始时间\n        memory_percent, available_mb = safe_get_memory_info()\n        logger.info(f'Batch processing started - batch size: {self.batch_size}, memory usage: {memory_percent:.1f}%, available: {available_mb}MB')\n        \n        memory_optimization_enabled = not self.disable_memory_optimization\n        if not memory_optimization_enabled:\n            logger.info('Memory optimization disabled by user')\n        else:\n            logger.info('Memory optimization enabled')\n        \n        # 收集所有需要翻译的图片文件\n        image_tasks = []\n        for root, subdirs, files in os.walk(path):\n            files = natural_sort(files)\n            dest_root = replace_prefix(root, path, dest)\n            os.makedirs(dest_root, exist_ok=True)\n            \n            for f in files:\n                if f.lower() == '.thumb':\n                    continue\n                    \n                file_path = os.path.join(root, f)\n                output_dest = replace_prefix(file_path, path, dest)\n                p, ext = os.path.splitext(output_dest)\n                output_dest = f'{p}.{file_ext or ext[1:]}'\n                \n                # 检查是否需要跳过已翻译的文件\n                if not params.get('overwrite') and os.path.exists(output_dest):\n                    logger.debug(f'Skipping already translated file: \"{output_dest}\"')\n                    continue\n                    \n                # 尝试加载图片\n                try:\n                    img = Image.open(file_path)\n                    img.verify()\n                    img = Image.open(file_path)  # 重新打开因为verify会关闭文件\n                    image_tasks.append((img, config, file_path, output_dest))\n                except Exception as e:\n                    logger.warning(f'Failed to open image: {file_path}, error: {e}')\n                    continue\n        \n        if not image_tasks:\n            logger.info('No images found to translate, use --overwrite to write over existing translations.')\n            return\n            \n        logger.info(f'Found {len(image_tasks)} images to translate')\n        \n        # 简化的内存优化策略\n        base_batch_size = self.batch_size\n        translated_count = 0\n        i = 0\n        \n        while i < len(image_tasks):\n            # 使用固定批次大小\n            current_batch_size = base_batch_size\n                \n            batch = image_tasks[i:i + current_batch_size]\n            batch_num = i // base_batch_size + 1\n            total_batches = (len(image_tasks) + base_batch_size - 1) // base_batch_size\n            \n            logger.info(f'Processing batch {batch_num}/{total_batches} (size: {len(batch)})')\n            \n            # 内存状态检查\n            memory_percent, available_mb = safe_get_memory_info()\n            logger.debug(f'Memory status before batch: {memory_percent:.1f}%, available: {available_mb}MB')\n            \n            # 如果内存严重不足，强制清理\n            if memory_optimization_enabled and memory_percent > 90:\n                logger.warning(f'High memory usage detected ({memory_percent:.1f}%), forcing cleanup...')\n                force_cleanup()\n                memory_percent, available_mb = safe_get_memory_info()\n                logger.info(f'Memory status after cleanup: {memory_percent:.1f}%, available: {available_mb}MB')\n            \n            # 创建当前批次的配置副本\n            batch_config = config\n            if memory_optimization_enabled:\n                batch_config = copy.deepcopy(config)\n                \n                # 更新批次中的配置\n                images_with_configs = [(img, batch_config) for img, _, _, _ in batch]\n            else:\n                images_with_configs = [(img, config) for img, _, _, _ in batch]\n            \n            try:\n                # 批量翻译\n                logger.debug(f'Starting batch translation for {len(batch)} images...')\n                # 提取图片名称用于调试文件夹命名\n                image_names = [os.path.basename(file_path) for _, _, file_path, _ in batch]\n                batch_results = await self.translate_batch(images_with_configs, len(batch), image_names)\n                \n                # 保存结果\n                for j, (ctx, (img, _, file_path, output_dest)) in enumerate(zip(batch_results, batch)):\n                    # 检查是否应该跳过没有文本的图片（遵循skip_no_text参数）\n                    if self.skip_no_text and ctx and not ctx.text_regions:\n                        logger.debug(f'Not saving due to --skip-no-text: {file_path}')\n                        continue\n                        \n                    if ctx and ctx.result:\n                        logger.debug(f'Saving translation result: \"{output_dest}\"')\n                        save_ctx = Context(**params)\n                        save_ctx.result = ctx.result\n                        save_ctx.text_regions = ctx.text_regions\n                        save_ctx.gimp_font = batch_config.render.gimp_font\n                        save_ctx.save_quality = self.save_quality\n                        \n                        save_result(ctx.result, output_dest, save_ctx)\n                        translated_count += 1\n                        \n                        # 保存文本文件（如果需要）\n                        if self.save_text or self.save_text_file or self.prep_manual:\n                            if self.prep_manual:\n                                p, ext = os.path.splitext(output_dest)\n                                img_filename = p + '-orig' + ext\n                                img_path = os.path.join(os.path.dirname(output_dest), img_filename)\n                                img.save(img_path, quality=self.save_quality)\n                            if ctx.text_regions:\n                                self._save_text_to_file(file_path, ctx)\n                    else:\n                        # 处理没有结果的情况 - 改进逻辑以区分不同情况\n                        has_original_text = ctx and hasattr(ctx, 'text_regions') and ctx.text_regions\n                        \n                        if not ctx:\n                            logger.warning(f'Translation failed: {file_path} (context is None)')\n                            save_reason = \"no_context\"\n                        elif not hasattr(ctx, 'result'):\n                            logger.warning(f'Translation failed: {file_path} (no result attribute)')\n                            save_reason = \"no_result_attr\"\n                        elif ctx.result is None:\n                            if has_original_text:\n                                # 有原文但没有翻译结果，需要判断是否因为过滤导致\n                                # 检查是否所有region都被过滤掉了（有translation但为空或被过滤）\n                                filtered_by_processing = all(\n                                    hasattr(region, 'translation') and \n                                    (not region.translation.strip() or  # 空翻译\n                                     region.translation.isnumeric() or  # 数字翻译\n                                     region.text.lower().strip() == region.translation.lower().strip())  # 翻译与原文相同\n                                    for region in ctx.text_regions\n                                ) if ctx.text_regions else False\n                                \n                                if filtered_by_processing:\n                                    # logger.warning(f'Translation filtered out by post-processing: {file_path}')\n                                    save_reason = \"filtered_translation\"\n                                else:\n                                    # logger.warning(f'Translation failed with original text present: {file_path} (result is None but has text_regions)')\n                                    save_reason = \"translation_failed_with_text\"\n                            else:\n                                # logger.warning(f'Translation failed: {file_path} (result is None, no original text)')\n                                save_reason = \"no_original_text\"\n                        else:\n                            logger.warning(f'Translation failed: {file_path} (unexpected condition)')\n                            save_reason = \"unexpected\"\n                            \n                        # 决定是否保存图片\n                        should_save = True\n                        if save_reason == \"translation_failed_with_text\":\n                            # 有原文但翻译失败且不是因为过滤导致，不保存图片以便重试\n                            should_save = False\n                            # logger.info(f'Skipping save for retry: {file_path} (translation failed but has original text)')\n                        \n                        # 如果不跳过无文本图片，且决定保存，则保存原图\n                        if should_save and not self.skip_no_text:\n                            logger.info(f'Saving original image ({save_reason}): {file_path}')\n                            try:\n                                # 确保目标目录存在\n                                os.makedirs(os.path.dirname(output_dest), exist_ok=True)\n                                \n                                # 保存原图到目标位置\n                                if self.save_quality and self.save_quality < 100:\n                                    # 如果设置了压缩质量，转换为RGB并压缩保存\n                                    img_copy = img.convert('RGB') if img.mode != 'RGB' else img.copy()\n                                    img_copy.save(output_dest, quality=self.save_quality, format='JPEG')\n                                else:\n                                    # 保持原始格式和质量\n                                    img.save(output_dest)\n                                \n                                logger.info(f'Original image saved: \"{output_dest}\"')\n                                translated_count += 1  # 即使是原图也计入处理数量\n                            except Exception as save_error:\n                                logger.error(f'Failed to save original image: {file_path}, error: {save_error}')\n                        else:\n                            if not should_save:\n                                logger.debug(f'Skipped saving for retry: {file_path}')\n                            elif self.skip_no_text:\n                                logger.debug(f'Skipped saving due to --skip-no-text: {file_path}')\n                # 成功处理批次，重置连续错误计数\n                logger.debug(f'Batch {batch_num} processed successfully')\n                        \n            except (MemoryError, OSError) as e:\n                logger.error(f'Memory error in batch processing: {e}')\n                \n                if not memory_optimization_enabled:\n                    logger.error('Consider enabling memory optimization (remove --disable-memory-optimization flag)')\n                    raise\n                \n            except Exception as e:\n                logger.error(f'Other error in batch processing: {e}')\n                if not self.ignore_errors:\n                    raise\n                    \n            # 清理当前批次资源\n            for img, _, _, _ in batch:\n                if hasattr(img, 'close'):\n                    img.close()\n                del img\n            del batch\n            \n            # 每个批次后都执行内存清理\n            force_cleanup()\n            \n            # 内存状态报告\n            memory_percent, available_mb = safe_get_memory_info()\n            logger.debug(f'Memory status after batch {batch_num}: {memory_percent:.1f}%, available: {available_mb}MB')\n            \n            # 移动到下一批次\n            i += current_batch_size\n            \n        # 最终报告\n        total_time = time.time() - start_time  # 计算总耗时\n        \n        if translated_count == 0:\n            logger.info('No files to translate. Use --overwrite to overwrite existing translations.')\n        else:\n            # 格式化时间显示\n            if total_time >= 3600:  \n                time_str = f\"{total_time/3600:.1f} hours\"\n            elif total_time >= 60:  \n                time_str = f\"{total_time/60:.1f} minutes\"\n            else:  \n                time_str = f\"{total_time:.1f} seconds\"\n            \n            logger.info(f'Done! Translated {translated_count} image{\"\" if translated_count == 1 else \"s\"} in {time_str}')\n            logger.info(f'Results saved to: \"{dest}\"')\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}