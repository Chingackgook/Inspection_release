{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/ChatPaper",
    "API_Calls": [
        {
            "Name": "paper_summery",
            "Description": "这里也给出了接口实现（Reader）,接口依赖Paper类，同时大部分的详细流程控制位于Reader类和Paper类，外部chat_paper_main方法只进行简单的文件处理。整体是对pdf文献进行分三段总结",
            "Code": "import argparse\nimport base64\nimport configparser\nimport datetime\nimport json\nimport os\nimport re\nfrom collections import namedtuple\n\nimport arxiv\nimport numpy as np\nimport openai\nimport requests\nimport tenacity\nimport tiktoken\n\nimport fitz, io, os\nfrom PIL import Image\n\n\ndef chat_paper_main(args):\n    # 创建一个Reader对象，并调用show_info方法\n    if args.sort == 'Relevance':\n        sort = arxiv.SortCriterion.Relevance\n    elif args.sort == 'LastUpdatedDate':\n        sort = arxiv.SortCriterion.LastUpdatedDate\n    else:\n        sort = arxiv.SortCriterion.Relevance\n\n    if args.pdf_path:\n        reader1 = Reader(key_word=args.key_word,\n                         query=args.query,\n                         filter_keys=args.filter_keys,\n                         sort=sort,\n                         args=args\n                         )\n        reader1.show_info()\n        # 开始判断是路径还是文件：\n        paper_list = []\n        if args.pdf_path.endswith(\".pdf\"):\n            paper_list.append(Paper(path=args.pdf_path))\n        else:\n            for root, dirs, files in os.walk(args.pdf_path):\n                print(\"root:\", root, \"dirs:\", dirs, 'files:', files)  # 当前目录路径\n                for filename in files:\n                    # 如果找到PDF文件，则将其复制到目标文件夹中\n                    if filename.endswith(\".pdf\"):\n                        paper_list.append(Paper(path=os.path.join(root, filename)))\n        print(\"------------------paper_num: {}------------------\".format(len(paper_list)))\n        [print(paper_index, paper_name.path.split('\\\\')[-1]) for paper_index, paper_name in enumerate(paper_list)]\n        reader1.summary_with_chat(paper_list=paper_list)\n    else:\n        reader1 = Reader(key_word=args.key_word,\n                         query=args.query,\n                         filter_keys=args.filter_keys,\n                         sort=sort,\n                         args=args\n                         )\n        reader1.show_info()\n        filter_results = reader1.filter_arxiv(max_results=args.max_results)\n        paper_list = reader1.download_pdf(filter_results)\n        reader1.summary_with_chat(paper_list=paper_list)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--pdf_path\", type=str, default=r'demo.pdf', help=\"if none, the bot will download from arxiv with query\")\n    # parser.add_argument(\"--pdf_path\", type=str, default=r'C:\\sers\\Administrator\\Desktop\\DHER\\RHER_Reset\\ChatPaper', help=\"if none, the bot will download from arxiv with query\")\n    # parser.add_argument(\"--pdf_path\", type=str, default='', help=\"if none, the bot will download from arxiv with query\")\n    parser.add_argument(\"--query\", type=str, default='all: ChatGPT robot',\n                        help=\"the query string, ti: xx, au: xx, all: xx,\")\n    parser.add_argument(\"--key_word\", type=str, default='reinforcement learning',\n                        help=\"the key word of user research fields\")\n    parser.add_argument(\"--filter_keys\", type=str, default='ChatGPT robot',\n                        help=\"the filter key words, 摘要中每个单词都得有，才会被筛选为目标论文\")\n    parser.add_argument(\"--max_results\", type=int, default=1, help=\"the maximum number of results\")\n    # arxiv.SortCriterion.Relevance\n    parser.add_argument(\"--sort\", type=str, default=\"Relevance\", help=\"another is LastUpdatedDate\")\n    parser.add_argument(\"--save_image\", default=False,\n                        help=\"save image? It takes a minute or two to save a picture! But pretty\")\n    parser.add_argument(\"--file_format\", type=str, default='md', help=\"导出的文件格式，如果存图片的话，最好是md，如果不是的话，txt的不会乱\")\n    parser.add_argument(\"--language\", type=str, default='zh', help=\"The other output lauguage is English, is en\")    \n    import time\n\n    start_time = time.time()\n    chat_paper_main(args=parser.parse_args())\n    print(\"summary time:\", time.time() - start_time)\n\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/ChatPaper/chat_paper.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "class_Reader",
            "Description": "这是一个接口类，主要智能化模块是Reader类内的chat_conclusion方法、chat_method方法、chat_summary方法。这三个方法实现与大模型进行交互。类内其他方法多用于流程控制。",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/ChatPaper/chat_paper.py",
            "Implementation": "# 定义Reader类\nclass Reader:\n    # 初始化方法，设置属性\n    def __init__(self, key_word, query, filter_keys,\n                 root_path='./',\n                 gitee_key='',\n                 sort=arxiv.SortCriterion.SubmittedDate, user_name='defualt', args=None):\n        self.user_name = user_name  # 读者姓名\n        self.key_word = key_word  # 读者感兴趣的关键词\n        self.query = query  # 读者输入的搜索查询\n        self.sort = sort  # 读者选择的排序方式\n        if args.language == 'en':\n            self.language = 'English'\n        elif args.language == 'zh':\n            self.language = 'Chinese'\n        else:\n            self.language = 'Chinese'\n        self.filter_keys = filter_keys  # 用于在摘要中筛选的关键词\n        self.root_path = root_path\n        # 创建一个ConfigParser对象\n        self.config = configparser.ConfigParser()\n        # 读取配置文件\n        self.config.read('apikey.ini')\n        OPENAI_KEY = os.environ.get(\"OPENAI_KEY\", \"\")\n        # 获取某个键对应的值\n        openai.api_base = self.config.get('OpenAI', 'OPENAI_API_BASE')\n        self.chat_api_list = self.config.get('OpenAI', 'OPENAI_API_KEYS')[1:-1].replace('\\'', '').split(',')\n        self.chat_api_list.append(OPENAI_KEY)\n\n        # prevent short strings from being incorrectly used as API keys.\n        self.chat_api_list = [api.strip() for api in self.chat_api_list if len(api) > 20]\n        self.chatgpt_model = self.config.get('OpenAI', 'CHATGPT_MODEL')\n\n        # 如果已经设置了OpenAI key, 则不使用Azure Interface\n        if not self.chat_api_list:\n            self.chat_api_list.append(self.config.get('AzureOPenAI', 'OPENAI_API_KEYS'))\n            self.chatgpt_model = self.config.get('AzureOPenAI', 'CHATGPT_MODEL')\n\n            openai.api_base = self.config.get('AzureOPenAI', 'OPENAI_API_BASE')\n            openai.api_type = 'azure'\n            openai.api_version = self.config.get('AzureOPenAI', 'OPENAI_API_VERSION')\n\n        self.cur_api = 0\n        self.file_format = args.file_format\n        if args.save_image:\n            self.gitee_key = self.config.get('Gitee', 'api')\n        else:\n            self.gitee_key = ''\n        self.max_token_num = 4096\n        self.encoding = tiktoken.get_encoding(\"gpt2\")\n\n    def get_arxiv(self, max_results=30):\n        search = arxiv.Search(query=self.query,\n                              max_results=max_results,\n                              sort_by=self.sort,\n                              sort_order=arxiv.SortOrder.Descending,\n                              )\n        return search\n\n    def filter_arxiv(self, max_results=30):\n        search = self.get_arxiv(max_results=max_results)\n        print(\"all search:\")\n        for index, result in enumerate(search.results()):\n            print(index, result.title, result.updated)\n\n        filter_results = []\n        filter_keys = self.filter_keys\n\n        print(\"filter_keys:\", self.filter_keys)\n        # 确保每个关键词都能在摘要中找到，才算是目标论文\n        for index, result in enumerate(search.results()):\n            abs_text = result.summary.replace('-\\n', '-').replace('\\n', ' ')\n            meet_num = 0\n            for f_key in filter_keys.split(\" \"):\n                if f_key.lower() in abs_text.lower():\n                    meet_num += 1\n            if meet_num == len(filter_keys.split(\" \")):\n                filter_results.append(result)\n                # break\n        print(\"筛选后剩下的论文数量：\")\n        print(\"filter_results:\", len(filter_results))\n        print(\"filter_papers:\")\n        for index, result in enumerate(filter_results):\n            print(index, result.title, result.updated)\n        return filter_results\n\n    def validateTitle(self, title):\n        # 将论文的乱七八糟的路径格式修正\n        rstr = r\"[\\/\\\\\\:\\*\\?\\\"\\<\\>\\|]\"  # '/ \\ : * ? \" < > |'\n        new_title = re.sub(rstr, \"_\", title)  # 替换为下划线\n        return new_title\n\n    def download_pdf(self, filter_results):\n        # 先创建文件夹\n        date_str = str(datetime.datetime.now())[:13].replace(' ', '-')\n        key_word = str(self.key_word.replace(':', ' '))\n        path = self.root_path + 'pdf_files/' + self.query.replace('au: ', '').replace('title: ', '').replace('ti: ',\n                                                                                                             '').replace(\n            ':', ' ')[:25] + '-' + date_str\n        try:\n            os.makedirs(path)\n        except:\n            pass\n        print(\"All_paper:\", len(filter_results))\n        # 开始下载：\n        paper_list = []\n        for r_index, result in enumerate(filter_results):\n            try:\n                title_str = self.validateTitle(result.title)\n                pdf_name = title_str + '.pdf'\n                # result.download_pdf(path, filename=pdf_name)\n                self.try_download_pdf(result, path, pdf_name)\n                paper_path = os.path.join(path, pdf_name)\n                print(\"paper_path:\", paper_path)\n                paper = Paper(path=paper_path,\n                              url=result.entry_id,\n                              title=result.title,\n                              abs=result.summary.replace('-\\n', '-').replace('\\n', ' '),\n                              authers=[str(aut) for aut in result.authors],\n                              )\n                # 下载完毕，开始解析：\n                paper.parse_pdf()\n                paper_list.append(paper)\n            except Exception as e:\n                print(\"download_error:\", e)\n                pass\n        return paper_list\n\n    @tenacity.retry(wait=tenacity.wait_exponential(multiplier=1, min=4, max=10),\n                    stop=tenacity.stop_after_attempt(5),\n                    reraise=True)\n    def try_download_pdf(self, result, path, pdf_name):\n        result.download_pdf(path, filename=pdf_name)\n\n    @tenacity.retry(wait=tenacity.wait_exponential(multiplier=1, min=4, max=10),\n                    stop=tenacity.stop_after_attempt(5),\n                    reraise=True)\n    def upload_gitee(self, image_path, image_name='', ext='png'):\n        with open(image_path, 'rb') as f:\n            base64_data = base64.b64encode(f.read())\n            base64_content = base64_data.decode()\n\n        date_str = str(datetime.datetime.now())[:19].replace(':', '-').replace(' ', '-') + '.' + ext\n        path = image_name + '-' + date_str\n\n        payload = {\n            \"access_token\": self.gitee_key,\n            \"owner\": self.config.get('Gitee', 'owner'),\n            \"repo\": self.config.get('Gitee', 'repo'),\n            \"path\": self.config.get('Gitee', 'path'),\n            \"content\": base64_content,\n            \"message\": \"upload image\"\n        }\n        # 这里需要修改成你的gitee的账户和仓库名，以及文件夹的名字：\n        url = f'https://gitee.com/api/v5/repos/' + self.config.get('Gitee', 'owner') + '/' + self.config.get('Gitee',\n                                                                                                             'repo') + '/contents/' + self.config.get(\n            'Gitee', 'path') + '/' + path\n        rep = requests.post(url, json=payload).json()\n        print(\"rep:\", rep)\n        if 'content' in rep.keys():\n            image_url = rep['content']['download_url']\n        else:\n            image_url = r\"https://gitee.com/api/v5/repos/\" + self.config.get('Gitee', 'owner') + '/' + self.config.get(\n                'Gitee', 'repo') + '/contents/' + self.config.get('Gitee', 'path') + '/' + path\n\n        return image_url\n\n    def summary_with_chat(self, paper_list):\n        htmls = []\n        for paper_index, paper in enumerate(paper_list):\n            # 第一步先用title，abs，和introduction进行总结。\n            text = ''\n            text += 'Title:' + paper.title\n            text += 'Url:' + paper.url\n            text += 'Abstract:' + paper.abs\n            text += 'Paper_info:' + paper.section_text_dict['paper_info']\n            # intro\n            text += list(paper.section_text_dict.values())[0]\n            chat_summary_text = \"\"\n            try:\n                chat_summary_text = self.chat_summary(text=text)\n            except Exception as e:\n                print(\"summary_error:\", e)\n                import sys\n                exc_type, exc_obj, exc_tb = sys.exc_info()\n                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n                print(exc_type, fname, exc_tb.tb_lineno)\n                if \"maximum context\" in str(e):\n                    current_tokens_index = str(e).find(\"your messages resulted in\") + len(\n                        \"your messages resulted in\") + 1\n                    offset = int(str(e)[current_tokens_index:current_tokens_index + 4])\n                    summary_prompt_token = offset + 1000 + 150\n                    chat_summary_text = self.chat_summary(text=text, summary_prompt_token=summary_prompt_token)\n\n            htmls.append('## Paper:' + str(paper_index + 1))\n            htmls.append('\\n\\n\\n')\n            htmls.append(chat_summary_text)\n\n            # 第二步总结方法：\n            # TODO，由于有些文章的方法章节名是算法名，所以简单的通过关键词来筛选，很难获取，后面需要用其他的方案去优化。\n            method_key = ''\n            for parse_key in paper.section_text_dict.keys():\n                if 'method' in parse_key.lower() or 'approach' in parse_key.lower():\n                    method_key = parse_key\n                    break\n\n            if method_key != '':\n                text = ''\n                method_text = ''\n                summary_text = ''\n                summary_text += \"<summary>\" + chat_summary_text\n                # methods                \n                method_text += paper.section_text_dict[method_key]\n                text = summary_text + \"\\n\\n<Methods>:\\n\\n\" + method_text\n                chat_method_text = \"\"\n                try:\n                    chat_method_text = self.chat_method(text=text)\n                except Exception as e:\n                    print(\"method_error:\", e)\n                    import sys\n                    exc_type, exc_obj, exc_tb = sys.exc_info()\n                    fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n                    print(exc_type, fname, exc_tb.tb_lineno)\n                    if \"maximum context\" in str(e):\n                        current_tokens_index = str(e).find(\"your messages resulted in\") + len(\n                            \"your messages resulted in\") + 1\n                        offset = int(str(e)[current_tokens_index:current_tokens_index + 4])\n                        method_prompt_token = offset + 800 + 150\n                        chat_method_text = self.chat_method(text=text, method_prompt_token=method_prompt_token)\n                htmls.append(chat_method_text)\n            else:\n                chat_method_text = ''\n            htmls.append(\"\\n\" * 4)\n\n            # 第三步总结全文，并打分：\n            conclusion_key = ''\n            for parse_key in paper.section_text_dict.keys():\n                if 'conclu' in parse_key.lower():\n                    conclusion_key = parse_key\n                    break\n\n            text = ''\n            conclusion_text = ''\n            summary_text = ''\n            summary_text += \"<summary>\" + chat_summary_text + \"\\n <Method summary>:\\n\" + chat_method_text\n            if conclusion_key != '':\n                # conclusion                \n                conclusion_text += paper.section_text_dict[conclusion_key]\n                text = summary_text + \"\\n\\n<Conclusion>:\\n\\n\" + conclusion_text\n            else:\n                text = summary_text\n            chat_conclusion_text = \"\"\n            try:\n                chat_conclusion_text = self.chat_conclusion(text=text)\n            except Exception as e:\n                print(\"conclusion_error:\", e)\n                import sys\n                exc_type, exc_obj, exc_tb = sys.exc_info()\n                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n                print(exc_type, fname, exc_tb.tb_lineno)\n                if \"maximum context\" in str(e):\n                    current_tokens_index = str(e).find(\"your messages resulted in\") + len(\n                        \"your messages resulted in\") + 1\n                    offset = int(str(e)[current_tokens_index:current_tokens_index + 4])\n                    conclusion_prompt_token = offset + 800 + 150\n                    chat_conclusion_text = self.chat_conclusion(text=text,\n                                                                conclusion_prompt_token=conclusion_prompt_token)\n            htmls.append(chat_conclusion_text)\n            htmls.append(\"\\n\" * 4)\n\n            # # 整合成一个文件，打包保存下来。\n            date_str = str(datetime.datetime.now())[:13].replace(' ', '-')\n            export_path = os.path.join(self.root_path, 'export')\n            if not os.path.exists(export_path):\n                os.makedirs(export_path)\n            mode = 'w' if paper_index == 0 else 'a'\n            file_name = os.path.join(export_path,\n                                     date_str + '-' + self.validateTitle(paper.title[:80]) + \".\" + self.file_format)\n            self.export_to_markdown(\"\\n\".join(htmls), file_name=file_name, mode=mode)\n\n            # file_name = os.path.join(export_path, date_str+'-'+self.validateTitle(paper.title)+\".md\")\n            # self.export_to_markdown(\"\\n\".join(htmls), file_name=file_name, mode=mode)\n            htmls = []\n\n    @tenacity.retry(wait=tenacity.wait_exponential(multiplier=1, min=4, max=10),\n                    stop=tenacity.stop_after_attempt(5),\n                    reraise=True)\n    def chat_conclusion(self, text, conclusion_prompt_token=800):\n        openai.api_key = self.chat_api_list[self.cur_api]\n        self.cur_api += 1\n        self.cur_api = 0 if self.cur_api >= len(self.chat_api_list) - 1 else self.cur_api\n        text_token = len(self.encoding.encode(text))\n        clip_text_index = int(len(text) * (self.max_token_num - conclusion_prompt_token) / text_token)\n        clip_text = text[:clip_text_index]\n\n        messages = [\n            {\"role\": \"system\",\n             \"content\": \"You are a reviewer in the field of [\" + self.key_word + \"] and you need to critically review this article\"},\n            # chatgpt 角色\n            {\"role\": \"assistant\",\n             \"content\": \"This is the <summary> and <conclusion> part of an English literature, where <summary> you have already summarized, but <conclusion> part, I need your help to summarize the following questions:\" + clip_text},\n            # 背景知识，可以参考OpenReview的审稿流程\n            {\"role\": \"user\", \"content\": \\\"\\\"\\\"                 \n                 8. Make the following summary.Be sure to use {} answers (proper nouns need to be marked in English).\n                    - (1):What is the significance of this piece of work?\n                    - (2):Summarize the strengths and weaknesses of this article in three dimensions: innovation point, performance, and workload.                   \n                    .......\n                 Follow the format of the output later: \n                 8. Conclusion: \\n\\n\n                    - (1):xxx;\\n                     \n                    - (2):Innovation point: xxx; Performance: xxx; Workload: xxx;\\n                      \n                 \n                 Be sure to use {} answers (proper nouns need to be marked in English), statements as concise and academic as possible, do not repeat the content of the previous <summary>, the value of the use of the original numbers, be sure to strictly follow the format, the corresponding content output to xxx, in accordance with \\n line feed, ....... means fill in according to the actual requirements, if not, you can not write.                 \n                 \\\"\\\"\\\".format(self.language, self.language)},\n        ]\n\n        if openai.api_type == 'azure':\n            response = openai.ChatCompletion.create(\n                engine=self.chatgpt_model,\n                # prompt需要用英语替换，少占用token。\n                messages=messages,\n            )\n        else:\n            response = openai.ChatCompletion.create(\n                model=self.chatgpt_model,\n                # prompt需要用英语替换，少占用token。\n                messages=messages,\n            )\n        result = ''\n        for choice in response.choices:\n            result += choice.message.content\n        print(\"conclusion_result:\\n\", result)\n        print(\"prompt_token_used:\", response.usage.prompt_tokens,\n              \"completion_token_used:\", response.usage.completion_tokens,\n              \"total_token_used:\", response.usage.total_tokens)\n        print(\"response_time:\", response.response_ms / 1000.0, 's')\n        return result\n\n    @tenacity.retry(wait=tenacity.wait_exponential(multiplier=1, min=4, max=10),\n                    stop=tenacity.stop_after_attempt(5),\n                    reraise=True)\n    def chat_method(self, text, method_prompt_token=800):\n        openai.api_key = self.chat_api_list[self.cur_api]\n        self.cur_api += 1\n        self.cur_api = 0 if self.cur_api >= len(self.chat_api_list) - 1 else self.cur_api\n        text_token = len(self.encoding.encode(text))\n        clip_text_index = int(len(text) * (self.max_token_num - method_prompt_token) / text_token)\n        clip_text = text[:clip_text_index]\n        messages = [\n            {\"role\": \"system\",\n             \"content\": \"You are a researcher in the field of [\" + self.key_word + \"] who is good at summarizing papers using concise statements\"},\n            # chatgpt 角色\n            {\"role\": \"assistant\",\n             \"content\": \"This is the <summary> and <Method> part of an English document, where <summary> you have summarized, but the <Methods> part, I need your help to read and summarize the following questions.\" + clip_text},\n            # 背景知识\n            {\"role\": \"user\", \"content\": \\\"\\\"\\\"                 \n                 7. Describe in detail the methodological idea of this article. Be sure to use {} answers (proper nouns need to be marked in English). For example, its steps are.\n                    - (1):...\n                    - (2):...\n                    - (3):...\n                    - .......\n                 Follow the format of the output that follows: \n                 7. Methods: \\n\\n\n                    - (1):xxx;\\n \n                    - (2):xxx;\\n \n                    - (3):xxx;\\n  \n                    ....... \\n\\n     \n                 \n                 Be sure to use {} answers (proper nouns need to be marked in English), statements as concise and academic as possible, do not repeat the content of the previous <summary>, the value of the use of the original numbers, be sure to strictly follow the format, the corresponding content output to xxx, in accordance with \\n line feed, ....... means fill in according to the actual requirements, if not, you can not write.                 \n                 \\\"\\\"\\\".format(self.language, self.language)},\n        ]\n        if openai.api_type == 'azure':\n            response = openai.ChatCompletion.create(\n                engine=self.chatgpt_model,\n                # prompt需要用英语替换，少占用token。\n                messages=messages,\n            )\n        else:\n            response = openai.ChatCompletion.create(\n                model=self.chatgpt_model,\n                # prompt需要用英语替换，少占用token。\n                messages=messages,\n            )\n        result = ''\n        for choice in response.choices:\n            result += choice.message.content\n        print(\"method_result:\\n\", result)\n        print(\"prompt_token_used:\", response.usage.prompt_tokens,\n              \"completion_token_used:\", response.usage.completion_tokens,\n              \"total_token_used:\", response.usage.total_tokens)\n        print(\"response_time:\", response.response_ms / 1000.0, 's')\n        return result\n\n    @tenacity.retry(wait=tenacity.wait_exponential(multiplier=1, min=4, max=10),\n                    stop=tenacity.stop_after_attempt(5),\n                    reraise=True)\n    def chat_summary(self, text, summary_prompt_token=1100):\n        openai.api_key = self.chat_api_list[self.cur_api]\n        self.cur_api += 1\n        self.cur_api = 0 if self.cur_api >= len(self.chat_api_list) - 1 else self.cur_api\n        text_token = len(self.encoding.encode(text))\n        clip_text_index = int(len(text) * (self.max_token_num - summary_prompt_token) / text_token)\n        clip_text = text[:clip_text_index]\n        messages = [\n            {\"role\": \"system\",\n             \"content\": \"You are a researcher in the field of [\" + self.key_word + \"] who is good at summarizing papers using concise statements\"},\n            {\"role\": \"assistant\",\n             \"content\": \"This is the title, author, link, abstract and introduction of an English document. I need your help to read and summarize the following questions: \" + clip_text},\n            {\"role\": \"user\", \"content\": \\\"\\\"\\\"                 \n                 1. Mark the title of the paper (with Chinese translation)\n                 2. list all the authors' names (use English)\n                 3. mark the first author's affiliation (output {} translation only)                 \n                 4. mark the keywords of this article (use English)\n                 5. link to the paper, Github code link (if available, fill in Github:None if not)\n                 6. summarize according to the following four points.Be sure to use {} answers (proper nouns need to be marked in English)\n                    - (1):What is the research background of this article?\n                    - (2):What are the past methods? What are the problems with them? Is the approach well motivated?\n                    - (3):What is the research methodology proposed in this paper?\n                    - (4):On what task and what performance is achieved by the methods in this paper? Can the performance support their goals?\n                 Follow the format of the output that follows:                  \n                 1. Title: xxx\\n\\n\n                 2. Authors: xxx\\n\\n\n                 3. Affiliation: xxx\\n\\n                 \n                 4. Keywords: xxx\\n\\n   \n                 5. Urls: xxx or xxx , xxx \\n\\n      \n                 6. Summary: \\n\\n\n                    - (1):xxx;\\n \n                    - (2):xxx;\\n \n                    - (3):xxx;\\n  \n                    - (4):xxx.\\n\\n     \n                 \n                 Be sure to use {} answers (proper nouns need to be marked in English), statements as concise and academic as possible, do not have too much repetitive information, numerical values using the original numbers, be sure to strictly follow the format, the corresponding content output to xxx, in accordance with \\n line feed.                 \n                 \\\"\\\"\\\".format(self.language, self.language, self.language)},\n        ]\n\n        if openai.api_type == 'azure':\n            response = openai.ChatCompletion.create(\n                engine=self.chatgpt_model,\n                # prompt需要用英语替换，少占用token。\n                messages=messages,\n            )\n        else:\n            response = openai.ChatCompletion.create(\n                model=self.chatgpt_model,\n                # prompt需要用英语替换，少占用token。\n                messages=messages,\n            )\n        result = ''\n        for choice in response.choices:\n            result += choice.message.content\n        print(\"summary_result:\\n\", result)\n        print(\"prompt_token_used:\", response.usage.prompt_tokens,\n              \"completion_token_used:\", response.usage.completion_tokens,\n              \"total_token_used:\", response.usage.total_tokens)\n        print(\"response_time:\", response.response_ms / 1000.0, 's')\n        return result\n\n    def export_to_markdown(self, text, file_name, mode='w'):\n        # 使用markdown模块的convert方法，将文本转换为html格式\n        # html = markdown.markdown(text)\n        # 打开一个文件，以写入模式\n        with open(file_name, mode, encoding=\"utf-8\") as f:\n            # 将html格式的内容写入文件\n            f.write(text)\n\n            # 定义一个方法，打印出读者信息\n\n    def show_info(self):\n        print(f\"Key word: {self.key_word}\")\n        print(f\"Query: {self.query}\")\n        print(f\"Sort: {self.sort}\")",
            "Examples": [
                "\n"
            ]
        }
    ]
}