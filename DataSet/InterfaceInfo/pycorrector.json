{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/pycorrector",
    "API_Calls": [
        {
            "Name": "call_EnSpellCorrector",
            "Description": "call_EnSpellCorrector",
            "Code": "# -*- coding: utf-8 -*-\n\"\"\"\n@author:XuMing(xuming624@qq.com)\n@description: \n\"\"\"\n\nimport sys\nsys.path.append(\"../..\")\nfrom pycorrector import EnSpellCorrector\n\nif __name__ == '__main__':\n    # 1. 演示英文句子纠错\n    sent = \"what happending? how to speling it, can you gorrect it?\"\n    m = EnSpellCorrector()\n    details = m.correct(sent)\n    print(details)\n    print()\n\n    # 2. 演示英文句子列表纠错\n    sent_lst = ['what hapenning?','how to speling it', 'gorrect', 'i know']\n    for sent in sent_lst:\n        details = m.correct(sent)\n        print('[error] ', details)\n    print()\n\n    # 3. 演示自定义英文词典\n    sent = \"what is your name? shylock?\"\n    r = m.correct(sent)\n    print(r)\n    print('-' * 42)\n    my_dict = {'your': 120, 'name': 2, 'is': 1, 'shylock': 1, 'what': 1}  # word, freq\n    spell = EnSpellCorrector(word_freq_dict=my_dict)\n    r = spell.correct(sent)\n    print(r)\n    print()\n\n    # 4. 演示自定义纠错集\n    spell = EnSpellCorrector()\n    sent = \"what happt ? who is shylock.\"\n    r = spell.correct(sent)\n    print(r)\n    print('-' * 42)\n    spell.set_en_custom_confusion_dict('./my_custom_confusion.txt')\n    r = spell.correct(sent)\n    print(r)\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/pycorrector/examples/kenlm/en_correct_demo.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "EnSpellCorrector",
            "Description": "EnSpellCorrector",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/pycorrector/pycorrector/en_spell_corrector.py",
            "Implementation": "# -*- coding: utf-8 -*-\n\"\"\"\n@author:XuMing(xuming624@qq.com)\n@description: english correction\nrefer: http://norvig.com/spell-correct.html\n\"\"\"\n\nimport gzip\nimport json\nimport operator\nimport os\nfrom codecs import open\nfrom typing import List\n\nfrom loguru import logger\n\nfrom pycorrector.utils.text_utils import is_alphabet_string\nfrom pycorrector.utils.tokenizer import split_text_into_sentences_by_symbol\n\npwd_path = os.path.abspath(os.path.dirname(__file__))\n# 英文拼写词频文件\ndefault_en_dict_path = os.path.join(pwd_path, 'data/en.json.gz')\n\n\nclass EnSpellCorrector:\n    def __init__(self, word_freq_dict: dict = None, custom_confusion_dict: dict = None, en_dict_path: str = None):\n        \"\"\"\n        Init english spell corrector\n        Args:\n            word_freq_dict: Word freq dict, k=word, v=int(freq)\n            custom_confusion_dict:\n            en_dict_path:\n        \"\"\"\n        if word_freq_dict and en_dict_path:\n            raise ValueError('word_freq_dict and en_dict_path can not be set at the same time.')\n        if word_freq_dict is None:\n            word_freq_dict = {}\n        if custom_confusion_dict is None:\n            custom_confusion_dict = {}\n        if not word_freq_dict and en_dict_path is None:\n            en_dict_path = default_en_dict_path\n        self.word_freq_dict = word_freq_dict\n        self.custom_confusion_dict = custom_confusion_dict\n        if en_dict_path and os.path.exists(en_dict_path):\n            with gzip.open(en_dict_path, \"rb\") as f:\n                all_word_freq_dict = json.loads(f.read())\n                word_freq = {}\n                for k, v in all_word_freq_dict.items():\n                    # 英语常用单词3万个，取词频高于400\n                    if v > 400:\n                        word_freq[k] = v\n                self.word_freq_dict = word_freq\n                logger.debug(\"load en spell data: %s, size: %d\" % (\n                    en_dict_path, len(self.word_freq_dict)))\n        # 词频总和\n        self.sum_freq = sum(self.word_freq_dict.values())\n\n    @staticmethod\n    def edits1(word):\n        \"\"\"\n        all edits that are one edit away from 'word'\n        :param word:\n        :return:\n        \"\"\"\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        splits = [(word[:i], word[i:]) for i in range(len(word) + 1)]\n        deletes = [L + R[1:] for L, R in splits if R]\n        transposes = [L + R[1] + R[0] + R[2:] for L, R in splits if len(R) > 1]\n        replaces = [L + c + R[1:] for L, R in splits if R for c in letters]\n        inserts = [L + c + R for L, R in splits for c in letters]\n        return set(deletes + transposes + replaces + inserts)\n\n    def edits2(self, word):\n        \"\"\"\n        all edit that are two edits away from 'word'\n        :param word:\n        :return:\n        \"\"\"\n        return (e2 for e1 in self.edits1(word) for e2 in self.edits1(e1))\n\n    def known(self, word_freq_dict):\n        \"\"\"\n        the subset of 'word_freq_dict' that appear in the dictionary of word_freq_dict\n        :param word_freq_dict:\n        :param limit_count:\n        :return:\n        \"\"\"\n        return set(w for w in word_freq_dict if w in self.word_freq_dict)\n\n    def probability(self, word):\n        \"\"\"\n        probability of word\n        :param word:\n        :return:float\n        \"\"\"\n        return self.word_freq_dict.get(word, 0) / self.sum_freq\n\n    def candidates(self, word):\n        \"\"\"\n        generate possible spelling corrections for word.\n        :param word:\n        :return:\n        \"\"\"\n        return self.known([word]) or self.known(self.edits1(word)) or self.known(self.edits2(word)) or {word}\n\n    def correct_word(self, word):\n        \"\"\"\n        most probable spelling correction for word\n        :param word:\n        :param mini_prob:\n        :return:\n        \"\"\"\n        candi_prob = {i: self.probability(i) for i in self.candidates(word)}\n        sort_candi_prob = sorted(candi_prob.items(), key=operator.itemgetter(1))\n        return sort_candi_prob[-1][0]\n\n    @staticmethod\n    def _get_custom_confusion_dict(path):\n        \"\"\"\n        取自定义困惑集\n        :param path:\n        :return: dict, {variant: origin}, eg: {\"交通先行\": \"交通限行\"}\n        \"\"\"\n        confusion = {}\n        if path and os.path.exists(path):\n            with open(path, 'r', encoding='utf-8') as f:\n                for line in f:\n                    line = line.strip()\n                    if line.startswith('#'):\n                        continue\n                    terms = line.split()\n                    if len(terms) < 2:\n                        continue\n                    wrong = terms[0]\n                    right = terms[1]\n                    confusion[wrong] = right\n        return confusion\n\n    def set_en_custom_confusion_dict(self, path):\n        \"\"\"\n        设置混淆纠错词典\n        :param path:\n        :return:\n        \"\"\"\n        self.custom_confusion_dict = self._get_custom_confusion_dict(path)\n        logger.debug('Loaded en spell confusion path: %s, size: %d' % (path, len(self.custom_confusion_dict)))\n\n    def correct(self, sentence, include_symbol=True):\n        \"\"\"\n        most probable spelling correction for text\n        :param sentence: input query\n        :param include_symbol: True, default\n        :return: {'source': 'src', 'target': 'trg', 'errors': [(error_word, correct_word, position), ...]}\n        example:\n            cann you speling it? [['cann', 'can'], ['speling', 'spelling']]\n        \"\"\"\n        text_new = ''\n        details = []\n        blocks = split_text_into_sentences_by_symbol(sentence, include_symbol=include_symbol)\n        for w, idx in blocks:\n            # 大于1个字符的英文词\n            if len(w) > 1 and is_alphabet_string(w):\n                if w in self.custom_confusion_dict:\n                    corrected_item = self.custom_confusion_dict[w]\n                else:\n                    corrected_item = self.correct_word(w)\n                if corrected_item != w:\n                    begin_idx = idx\n                    detail_word = (w, corrected_item, begin_idx)\n                    details.append(detail_word)\n                    w = corrected_item\n            text_new += w\n        # 以begin_idx排序\n        details = sorted(details, key=operator.itemgetter(2))\n        return {'source': sentence, 'target': text_new, 'errors': details}\n\n    def correct_batch(self, sentences: List[str], **kwargs):\n        \"\"\"\n        批量句子纠错\n        :param sentences: 句子文本列表\n        :param kwargs: 其他参数\n        :return: list of {'source': 'src', 'target': 'trg', 'errors': [(error_word, correct_word, position), ...]}\n        \"\"\"\n        return [self.correct(s, **kwargs) for s in sentences]\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}