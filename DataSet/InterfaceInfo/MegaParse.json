{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/MegaParse/libs/megaparse/src",
    "API_Calls": [
        {
            "Name": "call_MegaParse",
            "Description": "call_MegaParse",
            "Code": "import os\nfrom dataclasses import dataclass\nfrom time import perf_counter\n\nfrom megaparse import MegaParse\nfrom megaparse.configs.auto import DeviceEnum, MegaParseConfig\n\n\n@dataclass\nclass File:\n    file_path: str\n    file_name: str\n    file_extension: str\n\n\ndef list_files_in_directory(directory_path: str) -> dict[str, list[File]]:\n    directory_dict = {}\n    for root, _, files in os.walk(directory_path):\n        folder_name = os.path.basename(root)\n        if len(folder_name) > 0:\n            file_list = []\n            for file_name in files:\n                file_path = os.path.join(root, file_name)\n                file_extension = os.path.splitext(file_name)[1]\n                file_list.append(\n                    File(\n                        file_path=file_path,\n                        file_name=file_name,\n                        file_extension=file_extension,\n                    )\n                )\n            directory_dict[folder_name] = file_list\n\n    return directory_dict\n\n\ndef main():\n    folder_path = \"/Users/amine/data/quivr/parsing/\"\n\n    list_files = list_files_in_directory(folder_path)\n    config = MegaParseConfig(device=DeviceEnum.CPU)\n    mp = MegaParse(config=config)\n\n    for folder_name, files in list_files.items():\n        print(f\"folder: {folder_name}\")\n        for file in files:\n            if file.file_extension == \".pdf\":\n                s = perf_counter()\n                result = mp.load(file.file_path)\n                if len(result) == 0:\n                    print(f\"\\t{file.file_name}:  can't parse \")\n                    continue\n\n                e = perf_counter()\n                print(f\"\\t {file.file_name} parsing took: {e-s:.2f}s\")\n\n\nif __name__ == \"__main__\":\n    els = main()\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/MegaParse/libs/megaparse/examples/parse_file_mp.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "MegaParse",
            "Description": "MegaParse impl",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/MegaParse/libs/megaparse/src/megaparse/megaparse.py",
            "Implementation": "import logging\nimport warnings\nfrom pathlib import Path\nfrom typing import IO, BinaryIO, List\n\nimport pypdfium2 as pdfium\nfrom megaparse_sdk.schema import document\nfrom megaparse_sdk.schema.extensions import FileExtension\nfrom megaparse_sdk.schema.parser_config import StrategyEnum\n\nfrom megaparse.configs.auto import MegaParseConfig\nfrom megaparse.exceptions.base import ParsingException\nfrom megaparse.formatter.base import BaseFormatter\nfrom megaparse.layout_detection.layout_detector import LayoutDetector\nfrom megaparse.models.page import Page, PageDimension\nfrom megaparse.parser.doctr_parser import DoctrParser\nfrom megaparse.parser.unstructured_parser import UnstructuredParser\nfrom megaparse.utils.strategy import (\n    determine_global_strategy,\n    get_page_strategy,\n)\n\nlogger = logging.getLogger(\"megaparse\")\n\n\nclass MegaParse:\n    def __init__(\n        self,\n        formatters: List[BaseFormatter] | None = None,\n        config: MegaParseConfig = MegaParseConfig(),\n        unstructured_strategy: StrategyEnum = StrategyEnum.AUTO,\n    ) -> None:\n        self.config = config\n        self.formatters = formatters\n        self.doctr_parser = DoctrParser(\n            text_det_config=self.config.doctr_config.text_det_config,\n            text_reco_config=self.config.doctr_config.text_reco_config,\n            device=self.config.device,\n            straighten_pages=self.config.doctr_config.straighten_pages,\n            detect_orientation=self.config.doctr_config.detect_orientation,\n            detect_language=self.config.doctr_config.detect_language,\n        )\n        self.unstructured_parser = UnstructuredParser()\n\n        self.layout_model = LayoutDetector()\n        self.unstructured_parser = UnstructuredParser(unstructured_strategy)\n\n    def validate_input(\n        self,\n        file_path: Path | str | None = None,\n        file: IO[bytes] | None = None,\n        file_extension: str | FileExtension | None = None,\n    ) -> FileExtension:\n        if not (file_path or file):\n            raise ValueError(\"Either file_path or file should be provided\")\n\n        if file_path and file:\n            raise ValueError(\"Only one of file_path or file should be provided\")\n\n        if file_path and file is None:\n            if isinstance(file_path, str):\n                file_path = Path(file_path)\n            file_extension = file_path.suffix\n        elif file and file_path is None:\n            if not file_extension:\n                raise ValueError(\n                    \"file_extension should be provided when given file argument\"\n                )\n            file.seek(0)\n        else:\n            raise ValueError(\"Either provider a file_path or file\")\n\n        if isinstance(file_extension, str):\n            try:\n                file_extension = FileExtension(file_extension)\n            except ValueError:\n                raise ValueError(f\"Unsupported file extension: {file_extension}\")\n        return file_extension\n\n    def extract_page_strategies(\n        self, pdfium_document: pdfium.PdfDocument, rast_scale: int = 2\n    ) -> List[Page]:\n        pages = []\n        for i, pdfium_page in enumerate(pdfium_document):\n            rasterized_page = pdfium_page.render(scale=rast_scale)\n            assert (\n                abs(pdfium_page.get_width() * rast_scale - rasterized_page.width) <= 1\n            ), (\n                f\"Widths do not match within a margin of 1: \"\n                f\"{pdfium_page.get_width() * rast_scale} != {rasterized_page.width}\"\n            )\n            pages.append(\n                Page(\n                    strategy=StrategyEnum.AUTO,\n                    text_detections=None,\n                    rasterized=rasterized_page.to_pil(),\n                    page_size=PageDimension(\n                        width=pdfium_page.get_width() * rast_scale,\n                        height=pdfium_page.get_height() * rast_scale,\n                    ),\n                    page_index=i,\n                    pdfium_elements=pdfium_page,\n                )\n            )\n            pages.append(\n                Page(\n                    strategy=StrategyEnum.AUTO,\n                    text_detections=None,\n                    rasterized=rasterized_page.to_pil(),\n                    page_size=PageDimension(\n                        width=pdfium_page.get_width() * rast_scale,\n                        height=pdfium_page.get_height() * rast_scale,\n                    ),\n                    page_index=i,\n                    pdfium_elements=pdfium_page,\n                )\n            )\n\n        # ----\n        # Get text detection for each page -> PAGE\n\n        pages = self.doctr_parser.get_text_detections(pages)\n\n        # ---\n\n        # Get strategy per page -> PAGE\n        for page in pages:\n            page.strategy = get_page_strategy(\n                page.pdfium_elements,\n                page.text_detections,\n                threshold=self.config.auto_config.page_threshold,\n            )\n        return pages\n\n        pages = self.doctr_parser.get_text_detections(pages)\n\n        for page in pages:\n            page.strategy = get_page_strategy(\n                page.pdfium_elements,\n                page.text_detections,\n                threshold=self.config.auto_config.page_threshold,\n            )\n        return pages\n\n    def load(\n        self,\n        file_path: Path | str | None = None,\n        file: BinaryIO | None = None,\n        file_extension: str | FileExtension = \"\",\n        strategy: StrategyEnum = StrategyEnum.AUTO,\n    ) -> str:\n        file_extension = self.validate_input(\n            file=file, file_path=file_path, file_extension=file_extension\n        )\n        if file_extension != FileExtension.PDF or strategy == StrategyEnum.FAST:\n            self.unstructured_parser.strategy = strategy\n            return str(\n                self.unstructured_parser.convert(\n                    file_path=file_path, file=file, file_extension=file_extension\n                )\n            )\n        else:\n            opened_file = None\n            try:\n                if file_path:\n                    opened_file = open(file_path, \"rb\")\n                    file = opened_file\n\n                assert file is not None, \"No File provided\"\n\n                pdfium_document = pdfium.PdfDocument(file)\n\n                # Rasterize pages and extract text recognition\n                pages = self.extract_page_strategies(pdfium_document)\n                strategy = determine_global_strategy(\n                    pages, self.config.auto_config.document_threshold\n                )\n\n                # Extract layout model\n                assert all(p.rasterized for p in pages)\n                layout_result = self.layout_model([p.rasterized for p in pages])  # type: ignore\n\n                if strategy == StrategyEnum.HI_RES:\n                    logger.debug(\"Using doctr for text recognition\")\n                    parsed_document = self.doctr_parser.get_text_recognition(\n                        pages, layout_result\n                    )\n\n                else:\n                    logger.debug(\"Using Unstructured Parser\")\n                    self.unstructured_parser.strategy = StrategyEnum.FAST\n                    parsed_document = self.unstructured_parser.convert(\n                        file=file, file_extension=file_extension\n                    )\n\n                # additional attributes\n                parsed_document.file_name = str(file_path) if file_path else None\n                parsed_document.metadata = pdfium_document.get_metadata_dict()\n\n                # Format -> TODO: should be generic\n                if self.formatters:\n                    for formatter in self.formatters:\n                        if isinstance(parsed_document, str):\n                            warnings.warn(\n                                f\"The last step returned a string, the {formatter.__class__} and following will not be applied\",\n                                stacklevel=2,\n                            )\n                            break\n                        parsed_document = formatter.format(parsed_document)\n\n                if not isinstance(parsed_document, str):\n                    return str(parsed_document)\n                return parsed_document\n            except Exception as e:\n                logger.exception(f\"Error occured while parsing {file}: {e}\")\n                raise ParsingException(\n                    f\"Error while parsing file {file_path or file}, file_extension: {file_extension}: {e}\"\n                )\n            finally:\n                if opened_file:\n                    opened_file.close()\n\n    async def aload(\n        self,\n        file_path: Path | str | None = None,\n        file: BinaryIO | None = None,\n        file_extension: str | FileExtension = \"\",\n        strategy: StrategyEnum = StrategyEnum.AUTO,\n    ) -> str | document.Document:\n        file_extension = self.validate_input(\n            file=file, file_path=file_path, file_extension=file_extension\n        )\n        if file_extension != FileExtension.PDF or strategy == StrategyEnum.FAST:\n            self.unstructured_parser.strategy = strategy\n            parsed_document = await self.unstructured_parser.aconvert(\n                file_path=file_path, file=file, file_extension=file_extension\n            )\n            return str(parsed_document)\n        else:\n            opened_file = None\n            try:\n                if file_path:\n                    opened_file = open(file_path, \"rb\")\n                    file = opened_file\n\n                assert file is not None, \"No File provided\"\n                pdfium_document = pdfium.PdfDocument(file)\n                # Determine strategy\n                pages = self.extract_page_strategies(pdfium_document)\n                strategy = determine_global_strategy(\n                    pages, self.config.auto_config.document_threshold\n                )\n\n                # Run layout model\n                assert all(p.rasterized for p in pages)\n                layout_result = self.layout_model([p.rasterized for p in pages])  # type: ignore\n\n                if strategy == StrategyEnum.HI_RES:\n                    logger.info(\"Using Doctr for text recognition\")\n                    parsed_document = self.doctr_parser.get_text_recognition(\n                        pages, layout_result\n                    )\n\n                else:\n                    logger.info(\"Switching to Unstructured Parser\")\n                    self.unstructured_parser.strategy = StrategyEnum.FAST\n                    parsed_document = await self.unstructured_parser.aconvert(\n                        file=file, file_extension=file_extension\n                    )\n\n                parsed_document.file_name = str(file_path) if file_path else None\n                parsed_document.metadata = pdfium_document.get_metadata_dict()\n\n                if self.formatters:\n                    for formatter in self.formatters:\n                        if isinstance(parsed_document, str):\n                            warnings.warn(\n                                f\"The last step returned a string, the {formatter.__class__} and following will not be applied\",\n                                stacklevel=2,\n                            )\n                            break\n                        parsed_document = await formatter.aformat(parsed_document)\n\n                return parsed_document\n            except Exception as e:\n                raise ParsingException(\n                    f\"Error while parsing file {file_path or file}, file_extension: {file_extension}: {e}\"\n                )\n            finally:\n                if opened_file:\n                    opened_file.close()\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}