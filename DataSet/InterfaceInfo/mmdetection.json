{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/mmdetection",
    "API_Calls": [
        {
            "Name": "image_demo",
            "Description": "image_demo文件中调用该接口对单张或多张图像进行目标检测推理，绘制图片中各图像的边框",
            "Code": "# Copyright (c) OpenMMLab. All rights reserved.\n\"\"\"Image Demo.\n\nThis script adopts a new infenence class, currently supports image path,\nnp.array and folder input formats, and will support video and webcam\nin the future.\n\nExample:\n    Save visualizations and predictions results::\n\n        python demo/image_demo.py demo/demo.jpg rtmdet-s\n\n        python demo/image_demo.py demo/demo.jpg \\\n        configs/rtmdet/rtmdet_s_8xb32-300e_coco.py \\\n        --weights rtmdet_s_8xb32-300e_coco_20220905_161602-387a891e.pth\n\n        python demo/image_demo.py demo/demo.jpg \\\n        glip_atss_swin-t_a_fpn_dyhead_pretrain_obj365 --texts bench\n\n        python demo/image_demo.py demo/demo.jpg \\\n        glip_atss_swin-t_a_fpn_dyhead_pretrain_obj365 --texts 'bench . car .'\n\n        python demo/image_demo.py demo/demo.jpg \\\n        glip_atss_swin-t_a_fpn_dyhead_pretrain_obj365\n        --texts 'bench . car .' -c\n\n        python demo/image_demo.py demo/demo.jpg \\\n        glip_atss_swin-t_a_fpn_dyhead_pretrain_obj365 \\\n        --texts 'There are a lot of cars here.'\n\n        python demo/image_demo.py demo/demo.jpg \\\n        glip_atss_swin-t_a_fpn_dyhead_pretrain_obj365 \\\n        --texts '$: coco'\n\n        python demo/image_demo.py demo/demo.jpg \\\n        glip_atss_swin-t_a_fpn_dyhead_pretrain_obj365 \\\n        --texts '$: lvis' --pred-score-thr 0.7 \\\n        --palette random --chunked-size 80\n\n        python demo/image_demo.py demo/demo.jpg \\\n        grounding_dino_swin-t_pretrain_obj365_goldg_cap4m \\\n        --texts '$: lvis' --pred-score-thr 0.4 \\\n        --palette random --chunked-size 80\n\n        python demo/image_demo.py demo/demo.jpg \\\n        grounding_dino_swin-t_pretrain_obj365_goldg_cap4m \\\n        --texts \"a red car in the upper right corner\" \\\n        --tokens-positive -1\n\n    Visualize prediction results::\n\n        python demo/image_demo.py demo/demo.jpg rtmdet-ins-s --show\n\n        python demo/image_demo.py demo/demo.jpg rtmdet-ins_s_8xb32-300e_coco \\\n        --show\n\"\"\"\n\nimport ast\nfrom argparse import ArgumentParser\n\nfrom mmengine.logging import print_log\n\nfrom mmdet.apis import DetInferencer\nfrom mmdet.evaluation import get_classes\n\n\ndef parse_args():\n    parser = ArgumentParser()\n    parser.add_argument(\n        'inputs', type=str, help='Input image file or folder path.')\n    parser.add_argument(\n        'model',\n        type=str,\n        help='Config or checkpoint .pth file or the model name '\n        'and alias defined in metafile. The model configuration '\n        'file will try to read from .pth if the parameter is '\n        'a .pth weights file.')\n    parser.add_argument('--weights', default=None, help='Checkpoint file')\n    parser.add_argument(\n        '--out-dir',\n        type=str,\n        default='outputs',\n        help='Output directory of images or prediction results.')\n    # Once you input a format similar to $: xxx, it indicates that\n    # the prompt is based on the dataset class name.\n    # support $: coco, $: voc, $: cityscapes, $: lvis, $: imagenet_det.\n    # detail to `mmdet/evaluation/functional/class_names.py`\n    parser.add_argument(\n        '--texts', help='text prompt, such as \"bench . car .\", \"$: coco\"')\n    parser.add_argument(\n        '--device', default='cuda:0', help='Device used for inference')\n    parser.add_argument(\n        '--pred-score-thr',\n        type=float,\n        default=0.3,\n        help='bbox score threshold')\n    parser.add_argument(\n        '--batch-size', type=int, default=1, help='Inference batch size.')\n    parser.add_argument(\n        '--show',\n        action='store_true',\n        help='Display the image in a popup window.')\n    parser.add_argument(\n        '--no-save-vis',\n        action='store_true',\n        help='Do not save detection vis results')\n    parser.add_argument(\n        '--no-save-pred',\n        action='store_true',\n        help='Do not save detection json results')\n    parser.add_argument(\n        '--print-result',\n        action='store_true',\n        help='Whether to print the results.')\n    parser.add_argument(\n        '--palette',\n        default='none',\n        choices=['coco', 'voc', 'citys', 'random', 'none'],\n        help='Color palette used for visualization')\n    # only for GLIP and Grounding DINO\n    parser.add_argument(\n        '--custom-entities',\n        '-c',\n        action='store_true',\n        help='Whether to customize entity names? '\n        'If so, the input text should be '\n        '\"cls_name1 . cls_name2 . cls_name3 .\" format')\n    parser.add_argument(\n        '--chunked-size',\n        '-s',\n        type=int,\n        default=-1,\n        help='If the number of categories is very large, '\n        'you can specify this parameter to truncate multiple predictions.')\n    # only for Grounding DINO\n    parser.add_argument(\n        '--tokens-positive',\n        '-p',\n        type=str,\n        help='Used to specify which locations in the input text are of '\n        'interest to the user. -1 indicates that no area is of interest, '\n        'None indicates ignoring this parameter. '\n        'The two-dimensional array represents the start and end positions.')\n\n    call_args = vars(parser.parse_args())\n\n    if call_args['no_save_vis'] and call_args['no_save_pred']:\n        call_args['out_dir'] = ''\n\n    if call_args['model'].endswith('.pth'):\n        print_log('The model is a weight file, automatically '\n                  'assign the model to --weights')\n        call_args['weights'] = call_args['model']\n        call_args['model'] = None\n\n    if call_args['texts'] is not None:\n        if call_args['texts'].startswith('$:'):\n            dataset_name = call_args['texts'][3:].strip()\n            class_names = get_classes(dataset_name)\n            call_args['texts'] = [tuple(class_names)]\n\n    if call_args['tokens_positive'] is not None:\n        call_args['tokens_positive'] = ast.literal_eval(\n            call_args['tokens_positive'])\n\n    init_kws = ['model', 'weights', 'device', 'palette']\n    init_args = {}\n    for init_kw in init_kws:\n        init_args[init_kw] = call_args.pop(init_kw)\n\n    return init_args, call_args\n\n\ndef main():\n    init_args, call_args = parse_args()\n    # TODO: Video and Webcam are currently not supported and\n    #  may consume too much memory if your input folder has a lot of images.\n    #  We will be optimized later.\n    inferencer = DetInferencer(**init_args)\n\n    chunked_size = call_args.pop('chunked_size')\n    inferencer.model.test_cfg.chunked_size = chunked_size\n\n    inferencer(**call_args)\n\n    if call_args['out_dir'] != '' and not (call_args['no_save_vis']\n                                           and call_args['no_save_pred']):\n        print_log(f'results have been saved at {call_args[\"out_dir\"]}')\n\n\nif __name__ == '__main__':\n    main()\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/mmdetection/demo/image_demo.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "class_DetInferencer",
            "Description": "DetInferencer 类是一个用于目标检测推理的接口，能够帮助用户方便地使用预训练模型对输入图像进行目标检测，并支持结果可视化和保存。",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/mmdetection/mmdet/apis/det_inferencer.py",
            "Implementation": "# Copyright (c) OpenMMLab. All rights reserved.\nimport copy\nimport os.path as osp\nimport warnings\nfrom typing import Dict, Iterable, List, Optional, Sequence, Tuple, Union\n\nimport mmcv\nimport mmengine\nimport numpy as np\nimport torch.nn as nn\nfrom mmcv.transforms import LoadImageFromFile\nfrom mmengine.dataset import Compose\nfrom mmengine.fileio import (get_file_backend, isdir, join_path,\n                             list_dir_or_file)\nfrom mmengine.infer.infer import BaseInferencer, ModelType\nfrom mmengine.model.utils import revert_sync_batchnorm\nfrom mmengine.registry import init_default_scope\nfrom mmengine.runner.checkpoint import _load_checkpoint_to_model\nfrom mmengine.visualization import Visualizer\nfrom rich.progress import track\n\nfrom mmdet.evaluation import INSTANCE_OFFSET\nfrom mmdet.registry import DATASETS\nfrom mmdet.structures import DetDataSample\nfrom mmdet.structures.mask import encode_mask_results, mask2bbox\nfrom mmdet.utils import ConfigType\nfrom ..evaluation import get_classes\n\ntry:\n    from panopticapi.evaluation import VOID\n    from panopticapi.utils import id2rgb\nexcept ImportError:\n    id2rgb = None\n    VOID = None\n\nInputType = Union[str, np.ndarray]\nInputsType = Union[InputType, Sequence[InputType]]\nPredType = List[DetDataSample]\nImgType = Union[np.ndarray, Sequence[np.ndarray]]\n\nIMG_EXTENSIONS = ('.jpg', '.jpeg', '.png', '.ppm', '.bmp', '.pgm', '.tif',\n                  '.tiff', '.webp')\n\n\nclass DetInferencer(BaseInferencer):\n    \"\"\"Object Detection Inferencer.\n\n    Args:\n        model (str, optional): Path to the config file or the model name\n            defined in metafile. For example, it could be\n            \"rtmdet-s\" or 'rtmdet_s_8xb32-300e_coco' or\n            \"configs/rtmdet/rtmdet_s_8xb32-300e_coco.py\".\n            If model is not specified, user must provide the\n            `weights` saved by MMEngine which contains the config string.\n            Defaults to None.\n        weights (str, optional): Path to the checkpoint. If it is not specified\n            and model is a model name of metafile, the weights will be loaded\n            from metafile. Defaults to None.\n        device (str, optional): Device to run inference. If None, the available\n            device will be automatically used. Defaults to None.\n        scope (str, optional): The scope of the model. Defaults to mmdet.\n        palette (str): Color palette used for visualization. The order of\n            priority is palette -> config -> checkpoint. Defaults to 'none'.\n        show_progress (bool): Control whether to display the progress\n            bar during the inference process. Defaults to True.\n    \"\"\"\n\n    preprocess_kwargs: set = set()\n    forward_kwargs: set = set()\n    visualize_kwargs: set = {\n        'return_vis',\n        'show',\n        'wait_time',\n        'draw_pred',\n        'pred_score_thr',\n        'img_out_dir',\n        'no_save_vis',\n    }\n    postprocess_kwargs: set = {\n        'print_result',\n        'pred_out_dir',\n        'return_datasamples',\n        'no_save_pred',\n    }\n\n    def __init__(self,\n                 model: Optional[Union[ModelType, str]] = None,\n                 weights: Optional[str] = None,\n                 device: Optional[str] = None,\n                 scope: Optional[str] = 'mmdet',\n                 palette: str = 'none',\n                 show_progress: bool = True) -> None:\n        # A global counter tracking the number of images processed, for\n        # naming of the output images\n        self.num_visualized_imgs = 0\n        self.num_predicted_imgs = 0\n        self.palette = palette\n        init_default_scope(scope)\n        super().__init__(\n            model=model, weights=weights, device=device, scope=scope)\n        self.model = revert_sync_batchnorm(self.model)\n        self.show_progress = show_progress\n\n    def _load_weights_to_model(self, model: nn.Module,\n                               checkpoint: Optional[dict],\n                               cfg: Optional[ConfigType]) -> None:\n        \"\"\"Loading model weights and meta information from cfg and checkpoint.\n\n        Args:\n            model (nn.Module): Model to load weights and meta information.\n            checkpoint (dict, optional): The loaded checkpoint.\n            cfg (Config or ConfigDict, optional): The loaded config.\n        \"\"\"\n\n        if checkpoint is not None:\n            _load_checkpoint_to_model(model, checkpoint)\n            checkpoint_meta = checkpoint.get('meta', {})\n            # save the dataset_meta in the model for convenience\n            if 'dataset_meta' in checkpoint_meta:\n                # mmdet 3.x, all keys should be lowercase\n                model.dataset_meta = {\n                    k.lower(): v\n                    for k, v in checkpoint_meta['dataset_meta'].items()\n                }\n            elif 'CLASSES' in checkpoint_meta:\n                # < mmdet 3.x\n                classes = checkpoint_meta['CLASSES']\n                model.dataset_meta = {'classes': classes}\n            else:\n                warnings.warn(\n                    'dataset_meta or class names are not saved in the '\n                    'checkpoint\\'s meta data, use COCO classes by default.')\n                model.dataset_meta = {'classes': get_classes('coco')}\n        else:\n            warnings.warn('Checkpoint is not loaded, and the inference '\n                          'result is calculated by the randomly initialized '\n                          'model!')\n            warnings.warn('weights is None, use COCO classes by default.')\n            model.dataset_meta = {'classes': get_classes('coco')}\n\n        # Priority:  args.palette -> config -> checkpoint\n        if self.palette != 'none':\n            model.dataset_meta['palette'] = self.palette\n        else:\n            test_dataset_cfg = copy.deepcopy(cfg.test_dataloader.dataset)\n            # lazy init. We only need the metainfo.\n            test_dataset_cfg['lazy_init'] = True\n            metainfo = DATASETS.build(test_dataset_cfg).metainfo\n            cfg_palette = metainfo.get('palette', None)\n            if cfg_palette is not None:\n                model.dataset_meta['palette'] = cfg_palette\n            else:\n                if 'palette' not in model.dataset_meta:\n                    warnings.warn(\n                        'palette does not exist, random is used by default. '\n                        'You can also set the palette to customize.')\n                    model.dataset_meta['palette'] = 'random'\n\n    def _init_pipeline(self, cfg: ConfigType) -> Compose:\n        \"\"\"Initialize the test pipeline.\"\"\"\n        pipeline_cfg = cfg.test_dataloader.dataset.pipeline\n\n        # For inference, the key of ``img_id`` is not used.\n        if 'meta_keys' in pipeline_cfg[-1]:\n            pipeline_cfg[-1]['meta_keys'] = tuple(\n                meta_key for meta_key in pipeline_cfg[-1]['meta_keys']\n                if meta_key != 'img_id')\n\n        load_img_idx = self._get_transform_idx(\n            pipeline_cfg, ('LoadImageFromFile', LoadImageFromFile))\n        if load_img_idx == -1:\n            raise ValueError(\n                'LoadImageFromFile is not found in the test pipeline')\n        pipeline_cfg[load_img_idx]['type'] = 'mmdet.InferencerLoader'\n        return Compose(pipeline_cfg)\n\n    def _get_transform_idx(self, pipeline_cfg: ConfigType,\n                           name: Union[str, Tuple[str, type]]) -> int:\n        \"\"\"Returns the index of the transform in a pipeline.\n\n        If the transform is not found, returns -1.\n        \"\"\"\n        for i, transform in enumerate(pipeline_cfg):\n            if transform['type'] in name:\n                return i\n        return -1\n\n    def _init_visualizer(self, cfg: ConfigType) -> Optional[Visualizer]:\n        \"\"\"Initialize visualizers.\n\n        Args:\n            cfg (ConfigType): Config containing the visualizer information.\n\n        Returns:\n            Visualizer or None: Visualizer initialized with config.\n        \"\"\"\n        visualizer = super()._init_visualizer(cfg)\n        visualizer.dataset_meta = self.model.dataset_meta\n        return visualizer\n\n    def _inputs_to_list(self, inputs: InputsType) -> list:\n        \"\"\"Preprocess the inputs to a list.\n\n        Preprocess inputs to a list according to its type:\n\n        - list or tuple: return inputs\n        - str:\n            - Directory path: return all files in the directory\n            - other cases: return a list containing the string. The string\n              could be a path to file, a url or other types of string according\n              to the task.\n\n        Args:\n            inputs (InputsType): Inputs for the inferencer.\n\n        Returns:\n            list: List of input for the :meth:`preprocess`.\n        \"\"\"\n        if isinstance(inputs, str):\n            backend = get_file_backend(inputs)\n            if hasattr(backend, 'isdir') and isdir(inputs):\n                # Backends like HttpsBackend do not implement `isdir`, so only\n                # those backends that implement `isdir` could accept the inputs\n                # as a directory\n                filename_list = list_dir_or_file(\n                    inputs, list_dir=False, suffix=IMG_EXTENSIONS)\n                inputs = [\n                    join_path(inputs, filename) for filename in filename_list\n                ]\n\n        if not isinstance(inputs, (list, tuple)):\n            inputs = [inputs]\n\n        return list(inputs)\n\n    def preprocess(self, inputs: InputsType, batch_size: int = 1, **kwargs):\n        \"\"\"Process the inputs into a model-feedable format.\n\n        Customize your preprocess by overriding this method. Preprocess should\n        return an iterable object, of which each item will be used as the\n        input of ``model.test_step``.\n\n        ``BaseInferencer.preprocess`` will return an iterable chunked data,\n        which will be used in __call__ like this:\n\n        .. code-block:: python\n\n            def __call__(self, inputs, batch_size=1, **kwargs):\n                chunked_data = self.preprocess(inputs, batch_size, **kwargs)\n                for batch in chunked_data:\n                    preds = self.forward(batch, **kwargs)\n\n        Args:\n            inputs (InputsType): Inputs given by user.\n            batch_size (int): batch size. Defaults to 1.\n\n        Yields:\n            Any: Data processed by the ``pipeline`` and ``collate_fn``.\n        \"\"\"\n        chunked_data = self._get_chunk_data(inputs, batch_size)\n        yield from map(self.collate_fn, chunked_data)\n\n    def _get_chunk_data(self, inputs: Iterable, chunk_size: int):\n        \"\"\"Get batch data from inputs.\n\n        Args:\n            inputs (Iterable): An iterable dataset.\n            chunk_size (int): Equivalent to batch size.\n\n        Yields:\n            list: batch data.\n        \"\"\"\n        inputs_iter = iter(inputs)\n        while True:\n            try:\n                chunk_data = []\n                for _ in range(chunk_size):\n                    inputs_ = next(inputs_iter)\n                    if isinstance(inputs_, dict):\n                        if 'img' in inputs_:\n                            ori_inputs_ = inputs_['img']\n                        else:\n                            ori_inputs_ = inputs_['img_path']\n                        chunk_data.append(\n                            (ori_inputs_,\n                             self.pipeline(copy.deepcopy(inputs_))))\n                    else:\n                        chunk_data.append((inputs_, self.pipeline(inputs_)))\n                yield chunk_data\n            except StopIteration:\n                if chunk_data:\n                    yield chunk_data\n                break\n\n    # TODO: Video and Webcam are currently not supported and\n    #  may consume too much memory if your input folder has a lot of images.\n    #  We will be optimized later.\n    def __call__(\n            self,\n            inputs: InputsType,\n            batch_size: int = 1,\n            return_vis: bool = False,\n            show: bool = False,\n            wait_time: int = 0,\n            no_save_vis: bool = False,\n            draw_pred: bool = True,\n            pred_score_thr: float = 0.3,\n            return_datasamples: bool = False,\n            print_result: bool = False,\n            no_save_pred: bool = True,\n            out_dir: str = '',\n            # by open image task\n            texts: Optional[Union[str, list]] = None,\n            # by open panoptic task\n            stuff_texts: Optional[Union[str, list]] = None,\n            # by GLIP and Grounding DINO\n            custom_entities: bool = False,\n            # by Grounding DINO\n            tokens_positive: Optional[Union[int, list]] = None,\n            **kwargs) -> dict:\n        \"\"\"Call the inferencer.\n\n        Args:\n            inputs (InputsType): Inputs for the inferencer.\n            batch_size (int): Inference batch size. Defaults to 1.\n            show (bool): Whether to display the visualization results in a\n                popup window. Defaults to False.\n            wait_time (float): The interval of show (s). Defaults to 0.\n            no_save_vis (bool): Whether to force not to save prediction\n                vis results. Defaults to False.\n            draw_pred (bool): Whether to draw predicted bounding boxes.\n                Defaults to True.\n            pred_score_thr (float): Minimum score of bboxes to draw.\n                Defaults to 0.3.\n            return_datasamples (bool): Whether to return results as\n                :obj:`DetDataSample`. Defaults to False.\n            print_result (bool): Whether to print the inference result w/o\n                visualization to the console. Defaults to False.\n            no_save_pred (bool): Whether to force not to save prediction\n                results. Defaults to True.\n            out_dir: Dir to save the inference results or\n                visualization. If left as empty, no file will be saved.\n                Defaults to ''.\n            texts (str | list[str]): Text prompts. Defaults to None.\n            stuff_texts (str | list[str]): Stuff text prompts of open\n                panoptic task. Defaults to None.\n            custom_entities (bool): Whether to use custom entities.\n                Defaults to False. Only used in GLIP and Grounding DINO.\n            **kwargs: Other keyword arguments passed to :meth:`preprocess`,\n                :meth:`forward`, :meth:`visualize` and :meth:`postprocess`.\n                Each key in kwargs should be in the corresponding set of\n                ``preprocess_kwargs``, ``forward_kwargs``, ``visualize_kwargs``\n                and ``postprocess_kwargs``.\n\n        Returns:\n            dict: Inference and visualization results.\n        \"\"\"\n        (\n            preprocess_kwargs,\n            forward_kwargs,\n            visualize_kwargs,\n            postprocess_kwargs,\n        ) = self._dispatch_kwargs(**kwargs)\n\n        ori_inputs = self._inputs_to_list(inputs)\n\n        if texts is not None and isinstance(texts, str):\n            texts = [texts] * len(ori_inputs)\n        if stuff_texts is not None and isinstance(stuff_texts, str):\n            stuff_texts = [stuff_texts] * len(ori_inputs)\n\n        # Currently only supports bs=1\n        tokens_positive = [tokens_positive] * len(ori_inputs)\n\n        if texts is not None:\n            assert len(texts) == len(ori_inputs)\n            for i in range(len(texts)):\n                if isinstance(ori_inputs[i], str):\n                    ori_inputs[i] = {\n                        'text': texts[i],\n                        'img_path': ori_inputs[i],\n                        'custom_entities': custom_entities,\n                        'tokens_positive': tokens_positive[i]\n                    }\n                else:\n                    ori_inputs[i] = {\n                        'text': texts[i],\n                        'img': ori_inputs[i],\n                        'custom_entities': custom_entities,\n                        'tokens_positive': tokens_positive[i]\n                    }\n        if stuff_texts is not None:\n            assert len(stuff_texts) == len(ori_inputs)\n            for i in range(len(stuff_texts)):\n                ori_inputs[i]['stuff_text'] = stuff_texts[i]\n\n        inputs = self.preprocess(\n            ori_inputs, batch_size=batch_size, **preprocess_kwargs)\n\n        results_dict = {'predictions': [], 'visualization': []}\n        for ori_imgs, data in (track(inputs, description='Inference')\n                               if self.show_progress else inputs):\n            preds = self.forward(data, **forward_kwargs)\n            visualization = self.visualize(\n                ori_imgs,\n                preds,\n                return_vis=return_vis,\n                show=show,\n                wait_time=wait_time,\n                draw_pred=draw_pred,\n                pred_score_thr=pred_score_thr,\n                no_save_vis=no_save_vis,\n                img_out_dir=out_dir,\n                **visualize_kwargs)\n            results = self.postprocess(\n                preds,\n                visualization,\n                return_datasamples=return_datasamples,\n                print_result=print_result,\n                no_save_pred=no_save_pred,\n                pred_out_dir=out_dir,\n                **postprocess_kwargs)\n            results_dict['predictions'].extend(results['predictions'])\n            if results['visualization'] is not None:\n                results_dict['visualization'].extend(results['visualization'])\n        return results_dict\n\n    def visualize(self,\n                  inputs: InputsType,\n                  preds: PredType,\n                  return_vis: bool = False,\n                  show: bool = False,\n                  wait_time: int = 0,\n                  draw_pred: bool = True,\n                  pred_score_thr: float = 0.3,\n                  no_save_vis: bool = False,\n                  img_out_dir: str = '',\n                  **kwargs) -> Union[List[np.ndarray], None]:\n        \"\"\"Visualize predictions.\n\n        Args:\n            inputs (List[Union[str, np.ndarray]]): Inputs for the inferencer.\n            preds (List[:obj:`DetDataSample`]): Predictions of the model.\n            return_vis (bool): Whether to return the visualization result.\n                Defaults to False.\n            show (bool): Whether to display the image in a popup window.\n                Defaults to False.\n            wait_time (float): The interval of show (s). Defaults to 0.\n            draw_pred (bool): Whether to draw predicted bounding boxes.\n                Defaults to True.\n            pred_score_thr (float): Minimum score of bboxes to draw.\n                Defaults to 0.3.\n            no_save_vis (bool): Whether to force not to save prediction\n                vis results. Defaults to False.\n            img_out_dir (str): Output directory of visualization results.\n                If left as empty, no file will be saved. Defaults to ''.\n\n        Returns:\n            List[np.ndarray] or None: Returns visualization results only if\n            applicable.\n        \"\"\"\n        if no_save_vis is True:\n            img_out_dir = ''\n\n        if not show and img_out_dir == '' and not return_vis:\n            return None\n\n        if self.visualizer is None:\n            raise ValueError('Visualization needs the \"visualizer\" term'\n                             'defined in the config, but got None.')\n\n        results = []\n\n        for single_input, pred in zip(inputs, preds):\n            if isinstance(single_input, str):\n                img_bytes = mmengine.fileio.get(single_input)\n                img = mmcv.imfrombytes(img_bytes)\n                img = img[:, :, ::-1]\n                img_name = osp.basename(single_input)\n            elif isinstance(single_input, np.ndarray):\n                img = single_input.copy()\n                img_num = str(self.num_visualized_imgs).zfill(8)\n                img_name = f'{img_num}.jpg'\n            else:\n                raise ValueError('Unsupported input type: '\n                                 f'{type(single_input)}')\n\n            out_file = osp.join(img_out_dir, 'vis',\n                                img_name) if img_out_dir != '' else None\n\n            self.visualizer.add_datasample(\n                img_name,\n                img,\n                pred,\n                show=show,\n                wait_time=wait_time,\n                draw_gt=False,\n                draw_pred=draw_pred,\n                pred_score_thr=pred_score_thr,\n                out_file=out_file,\n            )\n            results.append(self.visualizer.get_image())\n            self.num_visualized_imgs += 1\n\n        return results\n\n    def postprocess(\n        self,\n        preds: PredType,\n        visualization: Optional[List[np.ndarray]] = None,\n        return_datasamples: bool = False,\n        print_result: bool = False,\n        no_save_pred: bool = False,\n        pred_out_dir: str = '',\n        **kwargs,\n    ) -> Dict:\n        \"\"\"Process the predictions and visualization results from ``forward``\n        and ``visualize``.\n\n        This method should be responsible for the following tasks:\n\n        1. Convert datasamples into a json-serializable dict if needed.\n        2. Pack the predictions and visualization results and return them.\n        3. Dump or log the predictions.\n\n        Args:\n            preds (List[:obj:`DetDataSample`]): Predictions of the model.\n            visualization (Optional[np.ndarray]): Visualized predictions.\n            return_datasamples (bool): Whether to use Datasample to store\n                inference results. If False, dict will be used.\n            print_result (bool): Whether to print the inference result w/o\n                visualization to the console. Defaults to False.\n            no_save_pred (bool): Whether to force not to save prediction\n                results. Defaults to False.\n            pred_out_dir: Dir to save the inference results w/o\n                visualization. If left as empty, no file will be saved.\n                Defaults to ''.\n\n        Returns:\n            dict: Inference and visualization results with key ``predictions``\n            and ``visualization``.\n\n            - ``visualization`` (Any): Returned by :meth:`visualize`.\n            - ``predictions`` (dict or DataSample): Returned by\n                :meth:`forward` and processed in :meth:`postprocess`.\n                If ``return_datasamples=False``, it usually should be a\n                json-serializable dict containing only basic data elements such\n                as strings and numbers.\n        \"\"\"\n        if no_save_pred is True:\n            pred_out_dir = ''\n\n        result_dict = {}\n        results = preds\n        if not return_datasamples:\n            results = []\n            for pred in preds:\n                result = self.pred2dict(pred, pred_out_dir)\n                results.append(result)\n        elif pred_out_dir != '':\n            warnings.warn('Currently does not support saving datasample '\n                          'when return_datasamples is set to True. '\n                          'Prediction results are not saved!')\n        # Add img to the results after printing and dumping\n        result_dict['predictions'] = results\n        if print_result:\n            print(result_dict)\n        result_dict['visualization'] = visualization\n        return result_dict\n\n    # TODO: The data format and fields saved in json need further discussion.\n    #  Maybe should include model name, timestamp, filename, image info etc.\n    def pred2dict(self,\n                  data_sample: DetDataSample,\n                  pred_out_dir: str = '') -> Dict:\n        \"\"\"Extract elements necessary to represent a prediction into a\n        dictionary.\n\n        It's better to contain only basic data elements such as strings and\n        numbers in order to guarantee it's json-serializable.\n\n        Args:\n            data_sample (:obj:`DetDataSample`): Predictions of the model.\n            pred_out_dir: Dir to save the inference results w/o\n                visualization. If left as empty, no file will be saved.\n                Defaults to ''.\n\n        Returns:\n            dict: Prediction results.\n        \"\"\"\n        is_save_pred = True\n        if pred_out_dir == '':\n            is_save_pred = False\n\n        if is_save_pred and 'img_path' in data_sample:\n            img_path = osp.basename(data_sample.img_path)\n            img_path = osp.splitext(img_path)[0]\n            out_img_path = osp.join(pred_out_dir, 'preds',\n                                    img_path + '_panoptic_seg.png')\n            out_json_path = osp.join(pred_out_dir, 'preds', img_path + '.json')\n        elif is_save_pred:\n            out_img_path = osp.join(\n                pred_out_dir, 'preds',\n                f'{self.num_predicted_imgs}_panoptic_seg.png')\n            out_json_path = osp.join(pred_out_dir, 'preds',\n                                     f'{self.num_predicted_imgs}.json')\n            self.num_predicted_imgs += 1\n\n        result = {}\n        if 'pred_instances' in data_sample:\n            masks = data_sample.pred_instances.get('masks')\n            pred_instances = data_sample.pred_instances.numpy()\n            result = {\n                'labels': pred_instances.labels.tolist(),\n                'scores': pred_instances.scores.tolist()\n            }\n            if 'bboxes' in pred_instances:\n                result['bboxes'] = pred_instances.bboxes.tolist()\n            if masks is not None:\n                if 'bboxes' not in pred_instances or pred_instances.bboxes.sum(\n                ) == 0:\n                    # Fake bbox, such as the SOLO.\n                    bboxes = mask2bbox(masks.cpu()).numpy().tolist()\n                    result['bboxes'] = bboxes\n                encode_masks = encode_mask_results(pred_instances.masks)\n                for encode_mask in encode_masks:\n                    if isinstance(encode_mask['counts'], bytes):\n                        encode_mask['counts'] = encode_mask['counts'].decode()\n                result['masks'] = encode_masks\n\n        if 'pred_panoptic_seg' in data_sample:\n            if VOID is None:\n                raise RuntimeError(\n                    'panopticapi is not installed, please install it by: '\n                    'pip install git+https://github.com/cocodataset/'\n                    'panopticapi.git.')\n\n            pan = data_sample.pred_panoptic_seg.sem_seg.cpu().numpy()[0]\n            pan[pan % INSTANCE_OFFSET == len(\n                self.model.dataset_meta['classes'])] = VOID\n            pan = id2rgb(pan).astype(np.uint8)\n\n            if is_save_pred:\n                mmcv.imwrite(pan[:, :, ::-1], out_img_path)\n                result['panoptic_seg_path'] = out_img_path\n            else:\n                result['panoptic_seg'] = pan\n\n        if is_save_pred:\n            mmengine.dump(result, out_json_path)\n\n        return result\n",
            "Examples": [
                "import os\nimport ast\nfrom argparse import ArgumentParser\nfrom mmengine.logging import print_log\nfrom mmdet.apis import DetInferencer\nfrom mmdet.evaluation import get_classes\n\n\ndef parse_args():\n    parser = ArgumentParser()\n    parser.add_argument(\n        'inputs', type=str, help='Input image file or folder path.')\n    parser.add_argument(\n        'model',\n        type=str,\n        help='Config or checkpoint .pth file or the model name '\n             'and alias defined in metafile. The model configuration '\n             'file will try to read from .pth if the parameter is '\n             'a .pth weights file.')\n    parser.add_argument('--weights', default=None, help='Checkpoint file')\n    parser.add_argument(\n        '--out-dir',\n        type=str,\n        default='test_outputs',\n        help='Output directory of images or prediction results.')\n    parser.add_argument(\n        '--texts', help='text prompt, such as \"bench . car .\", \"$: coco\"')\n    parser.add_argument(\n        '--device', default='cuda:0', help='Device used for inference')\n    parser.add_argument(\n        '--pred-score-thr',\n        type=float,\n        default=0.3,\n        help='bbox score threshold')\n    parser.add_argument(\n        '--batch-size', type=int, default=1, help='Inference batch size.')\n    parser.add_argument(\n        '--show',\n        action='store_true',\n        help='Display the image in a popup window.')\n    parser.add_argument(\n        '--no-save-vis',\n        action='store_true',\n        help='Do not save detection vis results')\n    parser.add_argument(\n        '--no-save-pred',\n        action='store_true',\n        help='Do not save detection json results')\n    parser.add_argument(\n        '--print-result',\n        action='store_true',\n        help='Whether to print the results.')\n    parser.add_argument(\n        '--palette',\n        default='none',\n        choices=['coco', 'voc', 'citys', 'random', 'none'],\n        help='Color palette used for visualization')\n    parser.add_argument(\n        '--custom-entities',\n        '-c',\n        action='store_true',\n        help='Whether to customize entity names? '\n             'If so, the input text should be '\n             '\"cls_name1 . cls_name2 . cls_name3 .\" format')\n    parser.add_argument(\n        '--chunked-size',\n        '-s',\n        type=int,\n        default=-1,\n        help='If the number of categories is very large, '\n             'you can specify this parameter to truncate multiple predictions.')\n    parser.add_argument(\n        '--tokens-positive',\n        '-p',\n        type=str,\n        help='Used to specify which locations in the input text are of '\n             'interest to the user. -1 indicates that no area is of interest, '\n             'None indicates ignoring this parameter. '\n             'The two-dimensional array represents the start and end positions.')\n\n    call_args = vars(parser.parse_args())\n\n    if call_args['no_save_vis'] and call_args['no_save_pred']:\n        call_args['out_dir'] = ''\n\n    if call_args['model'].endswith('.pth'):\n        print_log('The model is a weight file, automatically '\n                  'assign the model to --weights')\n        call_args['weights'] = call_args['model']\n        call_args['model'] = None\n\n    if call_args['texts'] is not None:\n        if call_args['texts'].startswith('$:'):\n            dataset_name = call_args['texts'][3:].strip()\n            class_names = get_classes(dataset_name)\n            call_args['texts'] = [tuple(class_names)]\n\n    if call_args['tokens_positive'] is not None:\n        call_args['tokens_positive'] = ast.literal_eval(\n            call_args['tokens_positive'])\n\n    init_kws = ['model', 'weights', 'device', 'palette']\n    init_args = {}\n    for init_kw in init_kws:\n        init_args[init_kw] = call_args.pop(init_kw)\n\n    return init_args, call_args\n\n\ndef test_det_inferencer():\n    init_args, call_args = parse_args()\n    try:\n        inferencer = DetInferencer(**init_args)\n\n        chunked_size = call_args.pop('chunked_size')\n        inferencer.model.test_cfg.chunked_size = chunked_size\n\n        result = inferencer(**call_args)\n\n        if call_args['print_result']:\n            print(result)\n\n        if call_args['out_dir'] != '' and not (call_args['no_save_vis']\n                                               and call_args['no_save_pred']):\n            # 验证结果是否保存\n            if not call_args['no_save_vis']:\n                vis_dir = os.path.join(call_args['out_dir'], 'vis')\n                assert os.path.exists(vis_dir), f\"Visualization directory {vis_dir} does not exist.\"\n            if not call_args['no_save_pred']:\n                pred_dir = os.path.join(call_args['out_dir'], 'preds')\n                assert os.path.exists(pred_dir), f\"Prediction directory {pred_dir} does not exist.\"\n\n            print_log(f'results have been saved at {call_args[\"out_dir\"]}')\n        print(\"Test passed.\")\n    except Exception as e:\n        print(f\"Test failed: {e}\")\n\n\nif __name__ == '__main__':\n    test_det_inferencer()\n"
            ]
        }
    ]
}