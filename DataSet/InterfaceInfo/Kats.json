{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/Kats",
    "API_Calls": [
        {
            "Name": "call_SARIMAModel",
            "Description": "call SARIMAModel",
            "Code": "import pandas as pd\nimport numpy as np\nimport sys\nimport matplotlib.pyplot as plt\nimport warnings\n\nwarnings.simplefilter(action='ignore')\nsys.path.append(\"../\")\n\nfrom kats.consts import TimeSeriesData\n\ntry: # If running on Jupyter\n    air_passengers_df = pd.read_csv(\"../kats/data/air_passengers.csv\")\nexcept FileNotFoundError: # If running on colab\n    air_passengers_df = pd.read_csv(\"air_passengers.csv\")\n\n# Note: If the column holding the time values is not called time, you will want to specify the name of this column.\nair_passengers_df.columns = [\"time\", \"value\"]\nair_passengers_ts = TimeSeriesData(air_passengers_df)\n\n\nfrom kats.models.sarima import SARIMAModel, SARIMAParams\nwarnings.simplefilter(action='ignore')\n\n# create SARIMA param class\nparams = SARIMAParams(\n    p = 2, \n    d=1, \n    q=1, \n    trend = 'ct', \n    seasonal_order=(1,0,1,12)\n    )\n\n# initiate SARIMA model\nm = SARIMAModel(data=air_passengers_ts, params=params)\n\n# fit SARIMA model\nm.fit()\n\n# generate forecast values\nfcst = m.predict(\n    steps=30, \n    freq=\"MS\",\n    include_history=True\n    )\n\n# make plot to visualize\nm.plot()",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/Kats/tutorials/kats_201_forecasting.ipynb"
        }
    ],
    "API_Implementations": [
        {
            "Name": "SARIMAModel",
            "Description": "SARIMAModel",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/Kats/kats/models/sarima.py",
            "Implementation": "\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Tuple\n\nimport numpy as np\nimport numpy.typing as npt\nimport pandas as pd\nfrom kats.consts import Params, TimeSeriesData\nfrom kats.models.model import Model\nfrom kats.utils.parameter_tuning_utils import get_default_sarima_parameter_search_space\nfrom statsmodels.tsa.statespace.mlemodel import MLEResults\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\n\n# pyre-fixme[24]: Generic type `np.ndarray` expects 2 type parameters.\nArrayLike = np.ndarray\n\n\nclass SARIMAModel(Model[SARIMAParams]):\n    \"\"\"Model class for SARIMA.\n\n    This class provides fit, predict and plot methods for SARIMA model.\n\n    Attributes:\n        data: :class:`kats.consts.TimeSeriesData` object for input time series.\n        params: :class:`SARIMAParams` for model parameters.\n    \"\"\"\n\n    start_params: Optional[npt.NDArray] = None\n    transformed: Optional[bool] = None\n    includes_fixed: Optional[bool] = None\n    cov_type: Optional[str] = None\n    cov_kwds: Optional[Dict[str, Any]] = None\n    method: Optional[str] = None\n    maxiter: Optional[int] = None\n    full_output: Optional[bool] = None\n    disp: Optional[bool] = None\n    callback: Optional[Callable[[npt.NDArray], None]] = None\n    return_params: Optional[bool] = None\n    optim_score: Optional[str] = None\n    optim_complex_step: Optional[bool] = None\n    optim_hessian: Optional[str] = None\n    low_memory: Optional[bool] = None\n    model: Optional[MLEResults] = None\n    include_history: bool = False\n    alpha: float = 0.05\n    fcst_df: Optional[pd.DataFrame] = None\n    freq: Optional[float] = None\n    y_fcst: Optional[npt.NDArray] = None\n    y_fcst_lower: Optional[npt.NDArray] = None\n    y_fcst_upper: Optional[npt.NDArray] = None\n    dates: Optional[pd.DatetimeIndex] = None\n\n    def __init__(\n        self,\n        data: TimeSeriesData,\n        params: SARIMAParams,\n    ) -> None:\n        super().__init__(data, params)\n        # pyre-fixme[16]: `Optional` has no attribute `value`.\n        if not isinstance(self.data.value, pd.Series):\n            msg = f\"Only support univariate time series, but get {self.data.value}.\"\n            logging.error(msg)\n            raise ValueError(msg)\n\n    def fit(\n        self,\n        start_params: Optional[npt.NDArray] = None,\n        transformed: bool = True,\n        includes_fixed: bool = False,\n        cov_type: Optional[str] = None,\n        cov_kwds: Optional[Dict[str, Any]] = None,\n        method: str = \"lbfgs\",\n        maxiter: int = 50,\n        full_output: bool = True,\n        disp: bool = False,\n        callback: Optional[Callable[[npt.NDArray], None]] = None,\n        return_params: bool = False,\n        optim_score: Optional[str] = None,\n        optim_complex_step: bool = True,\n        optim_hessian: Optional[str] = None,\n        low_memory: bool = False,\n    ) -> None:\n        \"\"\"Fit SARIMA model by maximum likelihood via Kalman filter.\n\n        See reference\n        https://www.statsmodels.org/stable/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.fit.html#statsmodels.tsa.statespace.sarimax.SARIMAX.fit\n        for more details.\n\n        Args:\n            start_params: Optional; An array_like object for the initial guess of the\n                solution for the loglikelihood maximization.\n            transformed: Optional; A boolean to specify whether or not start_params\n                is already transformed. Default is True.\n            includes_fixed: Optional; A boolean to specify whether or not start_params\n                includes the fixed parameters in addition to the free parameters.\n                Default is False.\n            cov_type: Optional; A string for the method for calculating the covariance\n                matrix of parameter estimates. Can be 'opg' (outer product of gradient\n                estimator), 'oim' (observed information matrix estimator), 'approx'\n                (observed information matrix estimator), 'robust' (approximate\n                (quasi-maximum likelihood) covariance matrix), or 'robust_approx'.\n                Default is 'opg' when memory conservation is not used, otherwise\n                default is ‘approx’.\n            cov_kwds: Optional; A dictionary of arguments for covariance matrix\n                computation. See reference for more details.\n            method: Optional; A string for solver from scipy.optimize to be used.\n                Can be 'newton', 'nm', 'bfgs', 'lbfgs', 'powell', 'cg', 'ncg' or\n                'basinhopping'. Default is 'lbfgs'.\n            maxiter: Optional; An integer for the maximum number of iterations to\n                perform. Default is 50.\n            full_output: Optional; A boolean to specify whether or not to have all\n                available output in the Results object’s mle_retvals attribute.\n                Default is True.\n            disp: Optional; A boolean to specify whether or not to print convergence\n                messages. Default is False.\n            callback: Optional; A callable object to be called after each iteration.\n                Default is None.\n            return_params: Optional; A boolean to specify whether or not to return\n                only the array of maximizing parameters. Default is False.\n            optim_score: Optional; A string for the method by which the score vector\n                is calculated. Can be 'harvey', 'approx' or None. Default is None.\n            optim_complex_step: Optional; A boolean to specify whether or not to use\n                complex step differentiation when approximating the score. Default\n                is True.\n            optim_hessian: Optional; A string for the method by which the Hessian is\n                numerically approximated. Can be 'opg', 'oim', 'approx'. Default is\n                None.\n            low_memory: Optional; A boolean to specify whether or not to reduce memory\n                usage. If True, some features of the results object will not be\n                available. Default is False.\n\n        Returns:\n            None.\n        \"\"\"\n\n        logging.debug(\"Call fit() method\")\n        self.start_params = start_params\n        self.transformed = transformed\n        self.includes_fixed = includes_fixed\n        self.cov_type = cov_type\n        self.cov_kwds = cov_kwds\n        self.method = method\n        self.maxiter = maxiter\n        self.full_output = full_output\n        self.disp = disp\n        self.callback = callback\n        self.return_params = return_params\n        self.optim_score = optim_score\n        self.optim_complex_step = optim_complex_step\n        self.optim_hessian = optim_hessian\n        self.low_memory = low_memory\n\n        logging.info(\"Created SARIMA model.\")\n        sarima = SARIMAX(\n            # pyre-fixme[16]: `Optional` has no attribute `value`.\n            self.data.value,\n            order=(self.params.p, self.params.d, self.params.q),\n            exog=self.params.exog,\n            seasonal_order=self.params.seasonal_order,\n            trend=self.params.trend,\n            measurement_error=self.params.measurement_error,\n            time_varying_regression=self.params.time_varying_regression,\n            mle_regression=self.params.mle_regression,\n            simple_differencing=self.params.simple_differencing,\n            enforce_stationarity=self.params.enforce_stationarity,\n            enforce_invertibility=self.params.enforce_invertibility,\n            hamilton_representation=self.params.hamilton_representation,\n            concentrate_scale=self.params.concentrate_scale,\n            trend_offset=self.params.trend_offset,\n            use_exact_diffuse=self.params.use_exact_diffuse,\n        )\n        self.model = sarima.fit(\n            start_params=self.start_params,\n            transformed=self.transformed,\n            includes_fixed=self.includes_fixed,\n            cov_type=self.cov_type,\n            cov_kwds=self.cov_kwds,\n            method=self.method,\n            maxiter=self.maxiter,\n            full_output=self.full_output,\n            disp=self.disp,\n            callback=self.callback,\n            return_params=self.return_params,\n            optim_score=self.optim_score,\n            optim_complex_step=self.optim_complex_step,\n            optim_hessian=self.optim_hessian,\n            low_memory=self.low_memory,\n        )\n        logging.info(\"Fitted SARIMA.\")\n\n    # pyre-fixme[14]: `predict` overrides method defined in `Model` inconsistently.\n    # pyre-fixme[15]: `predict` overrides method defined in `Model` inconsistently.\n    def predict(\n        self,\n        steps: int,\n        exog: Optional[ArrayLike] = None,\n        include_history: bool = False,\n        alpha: float = 0.05,\n        **kwargs: Any,\n    ) -> pd.DataFrame:\n        \"\"\"Predict with fitted SARIMA model.\n\n        Args:\n            steps: An integer for forecast steps.\n            include_history: Optional; A boolearn to specify whether to include\n                historical data. Default is False.\n            alpha: A float for confidence level. Default is 0.05.\n            exog: A numpy array of exogenous values to be passed to forecast\n\n        Returns:\n            A :class:`pandas.DataFrame` of forecasts and confidence intervals.\n        \"\"\"\n        model = self.model\n        if model is None:\n            msg = \"Call fit() before predict().\"\n            logging.error(msg)\n            raise ValueError(msg)\n        if (self.params.exog is not None) and (exog is None):\n            msg = (\n                \"SARIMA model was initialized with exogenous variables. Exogenous \"\n                \"variables must be used to predict. use `exog=`\"\n            )\n            logging.error(msg)\n            raise ValueError(msg)\n\n        logging.debug(f\"Call predict() with parameters. steps:{steps}, kwargs:{kwargs}\")\n        self.include_history = include_history\n        # pyre-fixme[16]: `Optional` has no attribute `infer_freq_robust`.\n        self.freq = kwargs.get(\"freq\", self.data.infer_freq_robust())\n        self.alpha = alpha\n\n        fcst = model.get_forecast(steps, exog=exog)\n\n        logging.info(\"Generated forecast data from SARIMA model.\")\n        logging.debug(f\"Forecast data: {fcst}\")\n\n        if fcst.predicted_mean.isna().sum() == steps:\n            msg = (\n                \"SARIMA model fails to generate forecasts, i.e., all forecasts are \"\n                \"NaNs.\"\n            )\n            logging.error(msg)\n            raise ValueError(msg)\n\n        self.y_fcst = fcst.predicted_mean\n        pred_interval = fcst.conf_int(alpha=self.alpha)\n\n        if pred_interval.iloc[0, 0] < pred_interval.iloc[0, 1]:\n            self.y_fcst_lower = np.array(pred_interval.iloc[:, 0])\n            self.y_fcst_upper = np.array(pred_interval.iloc[:, 1])\n        else:\n            self.y_fcst_lower = np.array(pred_interval.iloc[:, 1])\n            self.y_fcst_upper = np.array(pred_interval.iloc[:, 0])\n\n        # pyre-fixme[16]: `Optional` has no attribute `time`.\n        last_date = self.data.time.max()\n        dates = pd.date_range(start=last_date, periods=steps + 1, freq=self.freq)\n\n        self.dates = dates[dates != last_date]  # Return correct number of periods\n\n        if include_history:\n            # generate historical fit\n            history_fcst = model.get_prediction(0)\n            history_ci = history_fcst.conf_int()\n            if (\"lower\" in history_ci.columns[0]) and (\n                \"upper\" in history_ci.columns[1]\n            ):\n                ci_lower_name, ci_upper_name = (\n                    history_ci.columns[0],\n                    history_ci.columns[1],\n                )\n            else:\n                msg = (\n                    \"Error when getting prediction interval from statsmodels SARIMA API\"\n                )\n                logging.error(msg)\n                raise ValueError(msg)\n            self.fcst_df = fcst_df = pd.DataFrame(\n                {\n                    \"time\": np.concatenate(\n                        # pyre-fixme[6]: For 1st argument expected `Union[_SupportsAr...\n                        (pd.to_datetime(self.data.time), self.dates)\n                    ),\n                    \"fcst\": np.concatenate((history_fcst.predicted_mean, self.y_fcst)),\n                    \"fcst_lower\": np.concatenate(\n                        (history_ci[ci_lower_name], self.y_fcst_lower)\n                    ),\n                    \"fcst_upper\": np.concatenate(\n                        (history_ci[ci_upper_name], self.y_fcst_upper)\n                    ),\n                },\n                copy=False,\n            )\n\n            # the first k elements of the fcst and lower/upper are not legitmate\n            # thus we need to assign np.nan to avoid confusion\n            # k = max(p, d, q) + max(P, D, Q) * seasonal_order + 1\n            k = (\n                max(self.params.p, self.params.d, self.params.q)\n                + max(self.params.seasonal_order[0:3]) * self.params.seasonal_order[3]\n                + 1\n            )\n\n            fcst_df.loc[0:k, [\"fcst\", \"fcst_lower\", \"fcst_upper\"]] = np.nan\n        else:\n            self.fcst_df = fcst_df = pd.DataFrame(\n                {\n                    \"time\": self.dates,\n                    \"fcst\": self.y_fcst,\n                    \"fcst_lower\": self.y_fcst_lower,\n                    \"fcst_upper\": self.y_fcst_upper,\n                },\n                copy=False,\n            )\n\n        logging.debug(f\"Return forecast data: {fcst_df}\")\n        return fcst_df\n\n    def __str__(self) -> str:\n        return \"SARIMA\"\n\n    @staticmethod\n    # pyre-fixme[15]: `get_parameter_search_space` overrides method defined in\n    #  `Model` inconsistently.\n    def get_parameter_search_space() -> List[Dict[str, Any]]:\n        \"\"\"Get default SARIMA parameter search space.\n\n        Returns:\n            A dictionary representing the default SARIMA parameter search space.\n        \"\"\"\n        return get_default_sarima_parameter_search_space()\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}