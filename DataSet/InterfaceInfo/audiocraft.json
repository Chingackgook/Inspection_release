{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/audiocraft",
    "API_Calls": [
        {
            "Name": "MusicGen_app",
            "Description": "加载预训练的MusicGen模型，设置音乐生成的参数，最终生成WAX文件",
            "Code": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# Updated to account for UI changes from https://github.com/rkfg/audiocraft/blob/long/app.py\n# also released under the MIT license.\n\nimport argparse\nfrom concurrent.futures import ProcessPoolExecutor\nimport logging\nimport os\nfrom pathlib import Path\nimport subprocess as sp\nimport sys\nfrom tempfile import NamedTemporaryFile\nimport time\nimport typing as tp\nimport warnings\n\nfrom einops import rearrange\nimport torch\nimport gradio as gr\n\nfrom audiocraft.data.audio_utils import convert_audio\nfrom audiocraft.data.audio import audio_write\nfrom audiocraft.models.encodec import InterleaveStereoCompressionModel\nfrom audiocraft.models import MusicGen, MultiBandDiffusion\n\n\nMODEL = None  # Last used model\nSPACE_ID = os.environ.get('SPACE_ID', '')\nIS_BATCHED = \"facebook/MusicGen\" in SPACE_ID or 'musicgen-internal/musicgen_dev' in SPACE_ID\nprint(IS_BATCHED)\nMAX_BATCH_SIZE = 12\nBATCHED_DURATION = 15\nINTERRUPTING = False\nMBD = None\n# We have to wrap subprocess call to clean a bit the log when using gr.make_waveform\n_old_call = sp.call\n\n\ndef _call_nostderr(*args, **kwargs):\n    # Avoid ffmpeg vomiting on the logs.\n    kwargs['stderr'] = sp.DEVNULL\n    kwargs['stdout'] = sp.DEVNULL\n    _old_call(*args, **kwargs)\n\n\nsp.call = _call_nostderr\n# Preallocating the pool of processes.\npool = ProcessPoolExecutor(4)\npool.__enter__()\n\n\ndef interrupt():\n    global INTERRUPTING\n    INTERRUPTING = True\n\n\nclass FileCleaner:\n    def __init__(self, file_lifetime: float = 3600):\n        self.file_lifetime = file_lifetime\n        self.files = []\n\n    def add(self, path: tp.Union[str, Path]):\n        self._cleanup()\n        self.files.append((time.time(), Path(path)))\n\n    def _cleanup(self):\n        now = time.time()\n        for time_added, path in list(self.files):\n            if now - time_added > self.file_lifetime:\n                if path.exists():\n                    path.unlink()\n                self.files.pop(0)\n            else:\n                break\n                \nfile_cleaner = FileCleaner()\n\n\ndef make_waveform(*args, **kwargs):\n    # Further remove some warnings.\n    be = time.time()\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        out = gr.make_waveform(*args, **kwargs)\n        print(\"Make a video took\", time.time() - be)\n        return out\n\n\ndef load_model(version='facebook/musicgen-melody'):\n    global MODEL\n    print(\"Loading model\", version)\n    if MODEL is None or MODEL.name != version:\n        # Clear PyTorch CUDA cache and delete model\n        del MODEL\n        torch.cuda.empty_cache()\n        MODEL = None  # in case loading would crash\n        MODEL = MusicGen.get_pretrained(version)\n\n\ndef load_diffusion():\n    global MBD\n    if MBD is None:\n        print(\"loading MBD\")\n        MBD = MultiBandDiffusion.get_mbd_musicgen()\n\n\ndef _do_predictions(texts, melodies, duration, progress=False, gradio_progress=None, **gen_kwargs):\n    MODEL.set_generation_params(duration=duration, **gen_kwargs)\n    print(\"new batch\", len(texts), texts, [None if m is None else (m[0], m[1].shape) for m in melodies])\n    be = time.time()\n    processed_melodies = []\n    target_sr = 32000\n    target_ac = 1\n    for melody in melodies:\n        if melody is None:\n            processed_melodies.append(None)\n        else:\n            sr, melody = melody[0], torch.from_numpy(melody[1]).to(MODEL.device).float().t()\n            if melody.dim() == 1:\n                melody = melody[None]\n            melody = melody[..., :int(sr * duration)]\n            melody = convert_audio(melody, sr, target_sr, target_ac)\n            processed_melodies.append(melody)\n\n    try:\n        if any(m is not None for m in processed_melodies):\n            outputs = MODEL.generate_with_chroma(\n                descriptions=texts,\n                melody_wavs=processed_melodies,\n                melody_sample_rate=target_sr,\n                progress=progress,\n                return_tokens=USE_DIFFUSION\n            )\n        else:\n            outputs = MODEL.generate(texts, progress=progress, return_tokens=USE_DIFFUSION)\n    except RuntimeError as e:\n        raise gr.Error(\"Error while generating \" + e.args[0])\n    if USE_DIFFUSION:\n        if gradio_progress is not None:\n            gradio_progress(1, desc='Running MultiBandDiffusion...')\n        tokens = outputs[1]\n        if isinstance(MODEL.compression_model, InterleaveStereoCompressionModel):\n            left, right = MODEL.compression_model.get_left_right_codes(tokens)\n            tokens = torch.cat([left, right])\n        outputs_diffusion = MBD.tokens_to_wav(tokens)\n        if isinstance(MODEL.compression_model, InterleaveStereoCompressionModel):\n            assert outputs_diffusion.shape[1] == 1  # output is mono\n            outputs_diffusion = rearrange(outputs_diffusion, '(s b) c t -> b (s c) t', s=2)\n        outputs = torch.cat([outputs[0], outputs_diffusion], dim=0)\n    outputs = outputs.detach().cpu().float()\n    pending_videos = []\n    out_wavs = []\n    for output in outputs:\n        with NamedTemporaryFile(\"wb\", suffix=\".wav\", delete=False) as file:\n            audio_write(\n                file.name, output, MODEL.sample_rate, strategy=\"loudness\",\n                loudness_headroom_db=16, loudness_compressor=True, add_suffix=False)\n            pending_videos.append(pool.submit(make_waveform, file.name))\n            out_wavs.append(file.name)\n            file_cleaner.add(file.name)\n    out_videos = [pending_video.result() for pending_video in pending_videos]\n    for video in out_videos:\n        file_cleaner.add(video)\n    print(\"batch finished\", len(texts), time.time() - be)\n    print(\"Tempfiles currently stored: \", len(file_cleaner.files))\n    return out_videos, out_wavs\n\n\ndef predict_batched(texts, melodies):\n    max_text_length = 512\n    texts = [text[:max_text_length] for text in texts]\n    load_model('facebook/musicgen-stereo-melody')\n    res = _do_predictions(texts, melodies, BATCHED_DURATION)\n    return res\n\n\ndef predict_full(model, model_path, decoder, text, melody, duration, topk, topp, temperature, cfg_coef, progress=gr.Progress()):\n    global INTERRUPTING\n    global USE_DIFFUSION\n    INTERRUPTING = False\n    progress(0, desc=\"Loading model...\")\n    model_path = model_path.strip()\n    if model_path:\n        if not Path(model_path).exists():\n            raise gr.Error(f\"Model path {model_path} doesn't exist.\")\n        if not Path(model_path).is_dir():\n            raise gr.Error(f\"Model path {model_path} must be a folder containing \"\n                           \"state_dict.bin and compression_state_dict_.bin.\")\n        model = model_path\n    if temperature < 0:\n        raise gr.Error(\"Temperature must be >= 0.\")\n    if topk < 0:\n        raise gr.Error(\"Topk must be non-negative.\")\n    if topp < 0:\n        raise gr.Error(\"Topp must be non-negative.\")\n\n    topk = int(topk)\n    if decoder == \"MultiBand_Diffusion\":\n        USE_DIFFUSION = True\n        progress(0, desc=\"Loading diffusion model...\")\n        load_diffusion()\n    else:\n        USE_DIFFUSION = False\n    load_model(model)\n\n    max_generated = 0\n\n    def _progress(generated, to_generate):\n        nonlocal max_generated\n        max_generated = max(generated, max_generated)\n        progress((min(max_generated, to_generate), to_generate))\n        if INTERRUPTING:\n            raise gr.Error(\"Interrupted.\")\n    MODEL.set_custom_progress_callback(_progress)\n\n    videos, wavs = _do_predictions(\n        [text], [melody], duration, progress=True,\n        top_k=topk, top_p=topp, temperature=temperature, cfg_coef=cfg_coef,\n        gradio_progress=progress)\n    if USE_DIFFUSION:\n        return videos[0], wavs[0], videos[1], wavs[1]\n    return videos[0], wavs[0], None, None\n\n\ndef toggle_audio_src(choice):\n    if choice == \"mic\":\n        return gr.update(source=\"microphone\", value=None, label=\"Microphone\")\n    else:\n        return gr.update(source=\"upload\", value=None, label=\"File\")\n\n\ndef toggle_diffusion(choice):\n    if choice == \"MultiBand_Diffusion\":\n        return [gr.update(visible=True)] * 2\n    else:\n        return [gr.update(visible=False)] * 2\n\n\ndef ui_full(launch_kwargs):\n    with gr.Blocks() as interface:\n        gr.Markdown(\n            \"\"\"\n            # MusicGen\n            This is your private demo for [MusicGen](https://github.com/facebookresearch/audiocraft),\n            a simple and controllable model for music generation\n            presented at: [\"Simple and Controllable Music Generation\"](https://huggingface.co/papers/2306.05284)\n            \"\"\"\n        )\n        with gr.Row():\n            with gr.Column():\n                with gr.Row():\n                    text = gr.Text(label=\"Input Text\", interactive=True)\n                    with gr.Column():\n                        radio = gr.Radio([\"file\", \"mic\"], value=\"file\",\n                                         label=\"Condition on a melody (optional) File or Mic\")\n                        melody = gr.Audio(sources=[\"upload\"], type=\"numpy\", label=\"File\",\n                                          interactive=True, elem_id=\"melody-input\")\n                with gr.Row():\n                    submit = gr.Button(\"Submit\")\n                    # Adapted from https://github.com/rkfg/audiocraft/blob/long/app.py, MIT license.\n                    _ = gr.Button(\"Interrupt\").click(fn=interrupt, queue=False)\n                with gr.Row():\n                    model = gr.Radio([\"facebook/musicgen-melody\", \"facebook/musicgen-medium\", \"facebook/musicgen-small\",\n                                      \"facebook/musicgen-large\", \"facebook/musicgen-melody-large\",\n                                      \"facebook/musicgen-stereo-small\", \"facebook/musicgen-stereo-medium\",\n                                      \"facebook/musicgen-stereo-melody\", \"facebook/musicgen-stereo-large\",\n                                      \"facebook/musicgen-stereo-melody-large\"],\n                                     label=\"Model\", value=\"facebook/musicgen-stereo-melody\", interactive=True)\n                    model_path = gr.Text(label=\"Model Path (custom models)\")\n                with gr.Row():\n                    decoder = gr.Radio([\"Default\", \"MultiBand_Diffusion\"],\n                                       label=\"Decoder\", value=\"Default\", interactive=True)\n                with gr.Row():\n                    duration = gr.Slider(minimum=1, maximum=120, value=10, label=\"Duration\", interactive=True)\n                with gr.Row():\n                    topk = gr.Number(label=\"Top-k\", value=250, interactive=True)\n                    topp = gr.Number(label=\"Top-p\", value=0, interactive=True)\n                    temperature = gr.Number(label=\"Temperature\", value=1.0, interactive=True)\n                    cfg_coef = gr.Number(label=\"Classifier Free Guidance\", value=3.0, interactive=True)\n            with gr.Column():\n                output = gr.Video(label=\"Generated Music\")\n                audio_output = gr.Audio(label=\"Generated Music (wav)\", type='filepath')\n                diffusion_output = gr.Video(label=\"MultiBand Diffusion Decoder\")\n                audio_diffusion = gr.Audio(label=\"MultiBand Diffusion Decoder (wav)\", type='filepath')\n        submit.click(toggle_diffusion, decoder, [diffusion_output, audio_diffusion], queue=False,\n                     show_progress=False).then(predict_full, inputs=[model, model_path, decoder, text, melody, duration, topk, topp,\n                                                                     temperature, cfg_coef],\n                                               outputs=[output, audio_output, diffusion_output, audio_diffusion])\n        radio.change(toggle_audio_src, radio, [melody], queue=False, show_progress=False)\n\n        gr.Examples(\n            fn=predict_full,\n            examples=[\n                [\n                    \"An 80s driving pop song with heavy drums and synth pads in the background\",\n                    \"./assets/bach.mp3\",\n                    \"facebook/musicgen-stereo-melody\",\n                    \"Default\"\n                ],\n                [\n                    \"A cheerful country song with acoustic guitars\",\n                    \"./assets/bolero_ravel.mp3\",\n                    \"facebook/musicgen-stereo-melody\",\n                    \"Default\"\n                ],\n                [\n                    \"90s rock song with electric guitar and heavy drums\",\n                    None,\n                    \"facebook/musicgen-stereo-medium\",\n                    \"Default\"\n                ],\n                [\n                    \"a light and cheerly EDM track, with syncopated drums, aery pads, and strong emotions\",\n                    \"./assets/bach.mp3\",\n                    \"facebook/musicgen-stereo-melody\",\n                    \"Default\"\n                ],\n                [\n                    \"lofi slow bpm electro chill with organic samples\",\n                    None,\n                    \"facebook/musicgen-stereo-medium\",\n                    \"Default\"\n                ],\n                [\n                    \"Punk rock with loud drum and power guitar\",\n                    None,\n                    \"facebook/musicgen-stereo-medium\",\n                    \"MultiBand_Diffusion\"\n                ],\n            ],\n            inputs=[text, melody, model, decoder],\n            outputs=[output]\n        )\n        gr.Markdown(\n            \"\"\"\n            ### More details\n\n            The model will generate a short music extract based on the description you provided.\n            The model can generate up to 30 seconds of audio in one pass.\n\n            The model was trained with description from a stock music catalog, descriptions that will work best\n            should include some level of details on the instruments present, along with some intended use case\n            (e.g. adding \"perfect for a commercial\" can somehow help).\n\n            Using one of the `melody` model (e.g. `musicgen-melody-*`), you can optionally provide a reference audio\n            from which a broad melody will be extracted.\n            The model will then try to follow both the description and melody provided.\n            For best results, the melody should be 30 seconds long (I know, the samples we provide are not...)\n\n            It is now possible to extend the generation by feeding back the end of the previous chunk of audio.\n            This can take a long time, and the model might lose consistency. The model might also\n            decide at arbitrary positions that the song ends.\n\n            **WARNING:** Choosing long durations will take a long time to generate (2min might take ~10min).\n            An overlap of 12 seconds is kept with the previously generated chunk, and 18 \"new\" seconds\n            are generated each time.\n\n            We present 10 model variations:\n            1. facebook/musicgen-melody -- a music generation model capable of generating music condition\n                on text and melody inputs. **Note**, you can also use text only.\n            2. facebook/musicgen-small -- a 300M transformer decoder conditioned on text only.\n            3. facebook/musicgen-medium -- a 1.5B transformer decoder conditioned on text only.\n            4. facebook/musicgen-large -- a 3.3B transformer decoder conditioned on text only.\n            5. facebook/musicgen-melody-large -- a 3.3B transformer decoder conditioned on and melody.\n            6. facebook/musicgen-stereo-*: same as the previous models but fine tuned to output stereo audio.\n\n            We also present two way of decoding the audio tokens\n            1. Use the default GAN based compression model. It can suffer from artifacts especially\n                for crashes, snares etc.\n            2. Use [MultiBand Diffusion](https://arxiv.org/abs/2308.02560). Should improve the audio quality,\n                at an extra computational cost. When this is selected, we provide both the GAN based decoded\n                audio, and the one obtained with MBD.\n\n            See [github.com/facebookresearch/audiocraft](https://github.com/facebookresearch/audiocraft/blob/main/docs/MUSICGEN.md)\n            for more details.\n            \"\"\"\n        )\n\n        interface.queue().launch(**launch_kwargs)\n\n\ndef ui_batched(launch_kwargs):\n    with gr.Blocks() as demo:\n        gr.Markdown(\n            \"\"\"\n            # MusicGen\n\n            This is the demo for [MusicGen](https://github.com/facebookresearch/audiocraft/blob/main/docs/MUSICGEN.md),\n            a simple and controllable model for music generation\n            presented at: [\"Simple and Controllable Music Generation\"](https://huggingface.co/papers/2306.05284).\n            <br/>\n            <a href=\"https://huggingface.co/spaces/facebook/MusicGen?duplicate=true\"\n                style=\"display: inline-block;margin-top: .5em;margin-right: .25em;\" target=\"_blank\">\n            <img style=\"margin-bottom: 0em;display: inline;margin-top: -.25em;\"\n                src=\"https://bit.ly/3gLdBN6\" alt=\"Duplicate Space\"></a>\n            for longer sequences, more control and no queue.</p>\n            \"\"\"\n        )\n        with gr.Row():\n            with gr.Column():\n                with gr.Row():\n                    text = gr.Text(label=\"Describe your music\", lines=2, interactive=True)\n                    with gr.Column():\n                        radio = gr.Radio([\"file\", \"mic\"], value=\"file\",\n                                         label=\"Condition on a melody (optional) File or Mic\")\n                        melody = gr.Audio(source=\"upload\", type=\"numpy\", label=\"File\",\n                                          interactive=True, elem_id=\"melody-input\")\n                with gr.Row():\n                    submit = gr.Button(\"Generate\")\n            with gr.Column():\n                output = gr.Video(label=\"Generated Music\")\n                audio_output = gr.Audio(label=\"Generated Music (wav)\", type='filepath')\n        submit.click(predict_batched, inputs=[text, melody],\n                     outputs=[output, audio_output], batch=True, max_batch_size=MAX_BATCH_SIZE)\n        radio.change(toggle_audio_src, radio, [melody], queue=False, show_progress=False)\n        gr.Examples(\n            fn=predict_batched,\n            examples=[\n                [\n                    \"An 80s driving pop song with heavy drums and synth pads in the background\",\n                    \"./assets/bach.mp3\",\n                ],\n                [\n                    \"A cheerful country song with acoustic guitars\",\n                    \"./assets/bolero_ravel.mp3\",\n                ],\n                [\n                    \"90s rock song with electric guitar and heavy drums\",\n                    None,\n                ],\n                [\n                    \"a light and cheerly EDM track, with syncopated drums, aery pads, and strong emotions bpm: 130\",\n                    \"./assets/bach.mp3\",\n                ],\n                [\n                    \"lofi slow bpm electro chill with organic samples\",\n                    None,\n                ],\n            ],\n            inputs=[text, melody],\n            outputs=[output]\n        )\n        gr.Markdown(\"\"\"\n        ### More details\n\n        The model will generate 15 seconds of audio based on the description you provided.\n        The model was trained with description from a stock music catalog, descriptions that will work best\n        should include some level of details on the instruments present, along with some intended use case\n        (e.g. adding \"perfect for a commercial\" can somehow help).\n\n        You can optionally provide a reference audio from which a broad melody will be extracted.\n        The model will then try to follow both the description and melody provided.\n        For best results, the melody should be 30 seconds long (I know, the samples we provide are not...)\n\n        You can access more control (longer generation, more models etc.) by clicking\n        the <a href=\"https://huggingface.co/spaces/facebook/MusicGen?duplicate=true\"\n                style=\"display: inline-block;margin-top: .5em;margin-right: .25em;\" target=\"_blank\">\n            <img style=\"margin-bottom: 0em;display: inline;margin-top: -.25em;\"\n                src=\"https://bit.ly/3gLdBN6\" alt=\"Duplicate Space\"></a>\n        (you will then need a paid GPU from HuggingFace).\n        If you have a GPU, you can run the gradio demo locally (click the link to our repo below for more info).\n        Finally, you can get a GPU for free from Google\n        and run the demo in [a Google Colab.](https://ai.honu.io/red/musicgen-colab).\n\n        See [github.com/facebookresearch/audiocraft](https://github.com/facebookresearch/audiocraft/blob/main/docs/MUSICGEN.md)\n        for more details. All samples are generated with the `stereo-melody` model.\n        \"\"\")\n\n        demo.queue(max_size=8 * 4).launch(**launch_kwargs)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        '--listen',\n        type=str,\n        default='0.0.0.0' if 'SPACE_ID' in os.environ else '127.0.0.1',\n        help='IP to listen on for connections to Gradio',\n    )\n    parser.add_argument(\n        '--username', type=str, default='', help='Username for authentication'\n    )\n    parser.add_argument(\n        '--password', type=str, default='', help='Password for authentication'\n    )\n    parser.add_argument(\n        '--server_port',\n        type=int,\n        default=0,\n        help='Port to run the server listener on',\n    )\n    parser.add_argument(\n        '--inbrowser', action='store_true', help='Open in browser'\n    )\n    parser.add_argument(\n        '--share', action='store_true', help='Share the gradio UI'\n    )\n\n    args = parser.parse_args()\n\n    launch_kwargs = {}\n    launch_kwargs['server_name'] = args.listen\n\n    if args.username and args.password:\n        launch_kwargs['auth'] = (args.username, args.password)\n    if args.server_port:\n        launch_kwargs['server_port'] = args.server_port\n    if args.inbrowser:\n        launch_kwargs['inbrowser'] = args.inbrowser\n    if args.share:\n        launch_kwargs['share'] = args.share\n\n    logging.basicConfig(level=logging.INFO, stream=sys.stderr)\n\n    # Show the interface\n    if IS_BATCHED:\n        global USE_DIFFUSION\n        USE_DIFFUSION = False\n        ui_batched(launch_kwargs)\n    else:\n        ui_full(launch_kwargs)\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/audiocraft/demos/musicgen_app.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "class_MusicGen",
            "Description": "用户可以输入一段文本描述，用于指导音乐生成，并可以设置生成音乐的时长、采样参数等生成视频或音频文件",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/audiocraft/audiocraft/models/musicgen.py",
            "Implementation": "\nimport typing as tp\nimport warnings\n\nimport torch\n\nfrom .encodec import CompressionModel\nfrom .genmodel import BaseGenModel\nfrom .lm import LMModel\nfrom .builders import get_debug_compression_model, get_debug_lm_model\nfrom .loaders import load_compression_model, load_lm_model\nfrom ..data.audio_utils import convert_audio\nfrom ..modules.conditioners import ConditioningAttributes, WavCondition, StyleConditioner\n\n\nMelodyList = tp.List[tp.Optional[torch.Tensor]]\nMelodyType = tp.Union[torch.Tensor, MelodyList]\n\n\n# backward compatible names mapping\n_HF_MODEL_CHECKPOINTS_MAP = {\n    \"small\": \"facebook/musicgen-small\",\n    \"medium\": \"facebook/musicgen-medium\",\n    \"large\": \"facebook/musicgen-large\",\n    \"melody\": \"facebook/musicgen-melody\",\n    \"style\": \"facebook/musicgen-style\",\n}\n\n\nclass MusicGen(BaseGenModel):\n    \"\"\"MusicGen main model with convenient generation API.\n\n    Args:\n        name (str): name of the model.\n        compression_model (CompressionModel): Compression model\n            used to map audio to invertible discrete representations.\n        lm (LMModel): Language model over discrete representations.\n        max_duration (float, optional): maximum duration the model can produce,\n            otherwise, inferred from the training params.\n    \"\"\"\n    def __init__(self, name: str, compression_model: CompressionModel, lm: LMModel,\n                 max_duration: tp.Optional[float] = None):\n        super().__init__(name, compression_model, lm, max_duration)\n        self.set_generation_params(duration=15)  # default duration\n\n    @staticmethod\n    def get_pretrained(name: str = 'facebook/musicgen-melody', device=None):\n        \"\"\"Return pretrained model, we provide four models:\n        - facebook/musicgen-small (300M), text to music,\n          # see: https://huggingface.co/facebook/musicgen-small\n        - facebook/musicgen-medium (1.5B), text to music,\n          # see: https://huggingface.co/facebook/musicgen-medium\n        - facebook/musicgen-melody (1.5B) text to music and text+melody to music,\n          # see: https://huggingface.co/facebook/musicgen-melody\n        - facebook/musicgen-large (3.3B), text to music,\n          # see: https://huggingface.co/facebook/musicgen-large\n        - facebook/musicgen-style (1.5 B), text and style to music,\n          # see: https://huggingface.co/facebook/musicgen-style\n        \"\"\"\n        if device is None:\n            if torch.cuda.device_count():\n                device = 'cuda'\n            else:\n                device = 'cpu'\n\n        if name == 'debug':\n            # used only for unit tests\n            compression_model = get_debug_compression_model(device)\n            lm = get_debug_lm_model(device)\n            return MusicGen(name, compression_model, lm, max_duration=30)\n\n        if name in _HF_MODEL_CHECKPOINTS_MAP:\n            warnings.warn(\n                \"MusicGen pretrained model relying on deprecated checkpoint mapping. \" +\n                f\"Please use full pre-trained id instead: facebook/musicgen-{name}\")\n            name = _HF_MODEL_CHECKPOINTS_MAP[name]\n\n        lm = load_lm_model(name, device=device)\n        compression_model = load_compression_model(name, device=device)\n        if 'self_wav' in lm.condition_provider.conditioners:\n            lm.condition_provider.conditioners['self_wav'].match_len_on_eval = True\n            lm.condition_provider.conditioners['self_wav']._use_masking = False\n\n        return MusicGen(name, compression_model, lm)\n\n    def set_generation_params(self, use_sampling: bool = True, top_k: int = 250,\n                              top_p: float = 0.0, temperature: float = 1.0,\n                              duration: float = 30.0, cfg_coef: float = 3.0,\n                              cfg_coef_beta: tp.Optional[float] = None,\n                              two_step_cfg: bool = False, extend_stride: float = 18,):\n        \"\"\"Set the generation parameters for MusicGen.\n\n        Args:\n            use_sampling (bool, optional): Use sampling if True, else do argmax decoding. Defaults to True.\n            top_k (int, optional): top_k used for sampling. Defaults to 250.\n            top_p (float, optional): top_p used for sampling, when set to 0 top_k is used. Defaults to 0.0.\n            temperature (float, optional): Softmax temperature parameter. Defaults to 1.0.\n            duration (float, optional): Duration of the generated waveform. Defaults to 30.0.\n            cfg_coef (float, optional): Coefficient used for classifier free guidance. Defaults to 3.0.\n            cfg_coef_beta (float, optional): beta coefficient in double classifier free guidance.\n                Should be only used for MusicGen melody if we want to push the text condition more than\n                the audio conditioning. See paragraph 4.3 in https://arxiv.org/pdf/2407.12563 to understand\n                double CFG.\n            two_step_cfg (bool, optional): If True, performs 2 forward for Classifier Free Guidance,\n                instead of batching together the two. This has some impact on how things\n                are padded but seems to have little impact in practice.\n            extend_stride: when doing extended generation (i.e. more than 30 seconds), by how much\n                should we extend the audio each time. Larger values will mean less context is\n                preserved, and shorter value will require extra computations.\n        \"\"\"\n        assert extend_stride < self.max_duration, \"Cannot stride by more than max generation duration.\"\n        self.extend_stride = extend_stride\n        self.duration = duration\n        self.generation_params = {\n            'use_sampling': use_sampling,\n            'temp': temperature,\n            'top_k': top_k,\n            'top_p': top_p,\n            'cfg_coef': cfg_coef,\n            'two_step_cfg': two_step_cfg,\n            'cfg_coef_beta': cfg_coef_beta,\n        }\n\n    def set_style_conditioner_params(self, eval_q: int = 3, excerpt_length: float = 3.0,\n                                     ds_factor: tp.Optional[int] = None,\n                                     encodec_n_q: tp.Optional[int] = None) -> None:\n        \"\"\"Set the parameters of the style conditioner\n        Args:\n            eval_q (int): the number of residual quantization streams used to quantize the style condition\n                the smaller it is, the narrower is the information bottleneck\n            excerpt_length (float): the excerpt length in seconds that is extracted from the audio\n                conditioning\n            ds_factor: (int): the downsampling factor used to downsample the style tokens before\n                using them as a prefix\n            encodec_n_q: (int, optional): if encodec is used as a feature extractor, sets the number\n                of streams that is used to extract features\n        \"\"\"\n        assert isinstance(self.lm.condition_provider.conditioners.self_wav, StyleConditioner), \\\n            \"Only use this function if you model is MusicGen-Style\"\n        self.lm.condition_provider.conditioners.self_wav.set_params(eval_q=eval_q,\n                                                                    excerpt_length=excerpt_length,\n                                                                    ds_factor=ds_factor,\n                                                                    encodec_n_q=encodec_n_q)\n\n    def generate_with_chroma(self, descriptions: tp.List[str], melody_wavs: MelodyType,\n                             melody_sample_rate: int, progress: bool = False,\n                             return_tokens: bool = False) -> tp.Union[torch.Tensor,\n                                                                      tp.Tuple[torch.Tensor, torch.Tensor]]:\n        \"\"\"Generate samples conditioned on text and melody.\n\n        Args:\n            descriptions (list of str): A list of strings used as text conditioning.\n            melody_wavs: (torch.Tensor or list of Tensor): A batch of waveforms used as\n                melody conditioning. Should have shape [B, C, T] with B matching the description length,\n                C=1 or 2. It can be [C, T] if there is a single description. It can also be\n                a list of [C, T] tensors.\n            melody_sample_rate: (int): Sample rate of the melody waveforms.\n            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.\n        \"\"\"\n        if isinstance(melody_wavs, torch.Tensor):\n            if melody_wavs.dim() == 2:\n                melody_wavs = melody_wavs[None]\n            if melody_wavs.dim() != 3:\n                raise ValueError(\"Melody wavs should have a shape [B, C, T].\")\n            melody_wavs = list(melody_wavs)\n        else:\n            for melody in melody_wavs:\n                if melody is not None:\n                    assert melody.dim() == 2, \"One melody in the list has the wrong number of dims.\"\n\n        melody_wavs = [\n            convert_audio(wav, melody_sample_rate, self.sample_rate, self.audio_channels)\n            if wav is not None else None\n            for wav in melody_wavs]\n        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions=descriptions, prompt=None,\n                                                                        melody_wavs=melody_wavs)\n        assert prompt_tokens is None\n        tokens = self._generate_tokens(attributes, prompt_tokens, progress)\n        if return_tokens:\n            return self.generate_audio(tokens), tokens\n        return self.generate_audio(tokens)\n\n    @torch.no_grad()\n    def _prepare_tokens_and_attributes(\n            self,\n            descriptions: tp.Sequence[tp.Optional[str]],\n            prompt: tp.Optional[torch.Tensor],\n            melody_wavs: tp.Optional[MelodyList] = None,\n    ) -> tp.Tuple[tp.List[ConditioningAttributes], tp.Optional[torch.Tensor]]:\n        \"\"\"Prepare model inputs.\n\n        Args:\n            descriptions (list of str): A list of strings used as text conditioning.\n            prompt (torch.Tensor): A batch of waveforms used for continuation.\n            melody_wavs (torch.Tensor, optional): A batch of waveforms\n                used as melody conditioning. Defaults to None.\n        \"\"\"\n        attributes = [\n            ConditioningAttributes(text={'description': description})\n            for description in descriptions]\n\n        if melody_wavs is None:\n            for attr in attributes:\n                attr.wav['self_wav'] = WavCondition(\n                    torch.zeros((1, 1, 1), device=self.device),\n                    torch.tensor([0], device=self.device),\n                    sample_rate=[self.sample_rate],\n                    path=[None])\n        else:\n            if 'self_wav' not in self.lm.condition_provider.conditioners:\n                raise RuntimeError(\"This model doesn't support melody conditioning. \"\n                                   \"Use the `melody` model.\")\n            assert len(melody_wavs) == len(descriptions), \\\n                f\"number of melody wavs must match number of descriptions! \" \\\n                f\"got melody len={len(melody_wavs)}, and descriptions len={len(descriptions)}\"\n            for attr, melody in zip(attributes, melody_wavs):\n                if melody is None:\n                    attr.wav['self_wav'] = WavCondition(\n                        torch.zeros((1, 1, 1), device=self.device),\n                        torch.tensor([0], device=self.device),\n                        sample_rate=[self.sample_rate],\n                        path=[None])\n                else:\n                    attr.wav['self_wav'] = WavCondition(\n                        melody[None].to(device=self.device),\n                        torch.tensor([melody.shape[-1]], device=self.device),\n                        sample_rate=[self.sample_rate],\n                        path=[None],\n                    )\n\n        if prompt is not None:\n            if descriptions is not None:\n                assert len(descriptions) == len(prompt), \"Prompt and nb. descriptions doesn't match\"\n            prompt = prompt.to(self.device)\n            prompt_tokens, scale = self.compression_model.encode(prompt)\n            assert scale is None\n        else:\n            prompt_tokens = None\n        return attributes, prompt_tokens\n\n    def _generate_tokens(self, attributes: tp.List[ConditioningAttributes],\n                         prompt_tokens: tp.Optional[torch.Tensor], progress: bool = False) -> torch.Tensor:\n        \"\"\"Generate discrete audio tokens given audio prompt and/or conditions.\n\n        Args:\n            attributes (list of ConditioningAttributes): Conditions used for generation (text/melody).\n            prompt_tokens (torch.Tensor, optional): Audio prompt used for continuation.\n            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.\n        Returns:\n            torch.Tensor: Generated audio, of shape [B, C, T], T is defined by the generation params.\n        \"\"\"\n        total_gen_len = int(self.duration * self.frame_rate)\n        max_prompt_len = int(min(self.duration, self.max_duration) * self.frame_rate)\n        current_gen_offset: int = 0\n\n        def _progress_callback(generated_tokens: int, tokens_to_generate: int):\n            generated_tokens += current_gen_offset\n            if self._progress_callback is not None:\n                # Note that total_gen_len might be quite wrong depending on the\n                # codebook pattern used, but with delay it is almost accurate.\n                self._progress_callback(generated_tokens, tokens_to_generate)\n            else:\n                print(f'{generated_tokens: 6d} / {tokens_to_generate: 6d}', end='\\r')\n\n        if prompt_tokens is not None:\n            assert max_prompt_len >= prompt_tokens.shape[-1], \\\n                \"Prompt is longer than audio to generate\"\n\n        callback = None\n        if progress:\n            callback = _progress_callback\n\n        if self.duration <= self.max_duration:\n            # generate by sampling from LM, simple case.\n            with self.autocast:\n                gen_tokens = self.lm.generate(\n                    prompt_tokens, attributes,\n                    callback=callback, max_gen_len=total_gen_len, **self.generation_params)\n\n        else:\n            # now this gets a bit messier, we need to handle prompts,\n            # melody conditioning etc.\n            ref_wavs = [attr.wav['self_wav'] for attr in attributes]\n            all_tokens = []\n            if prompt_tokens is None:\n                prompt_length = 0\n            else:\n                all_tokens.append(prompt_tokens)\n                prompt_length = prompt_tokens.shape[-1]\n\n            assert self.extend_stride is not None, \"Stride should be defined to generate beyond max_duration\"\n            assert self.extend_stride < self.max_duration, \"Cannot stride by more than max generation duration.\"\n            stride_tokens = int(self.frame_rate * self.extend_stride)\n\n            while current_gen_offset + prompt_length < total_gen_len:\n                time_offset = current_gen_offset / self.frame_rate\n                chunk_duration = min(self.duration - time_offset, self.max_duration)\n                max_gen_len = int(chunk_duration * self.frame_rate)\n                for attr, ref_wav in zip(attributes, ref_wavs):\n                    wav_length = ref_wav.length.item()\n                    if wav_length == 0:\n                        continue\n                    # We will extend the wav periodically if it not long enough.\n                    # we have to do it here rather than in conditioners.py as otherwise\n                    # we wouldn't have the full wav.\n                    initial_position = int(time_offset * self.sample_rate)\n                    wav_target_length = int(self.max_duration * self.sample_rate)\n                    positions = torch.arange(initial_position,\n                                             initial_position + wav_target_length, device=self.device)\n                    attr.wav['self_wav'] = WavCondition(\n                        ref_wav[0][..., positions % wav_length],\n                        torch.full_like(ref_wav[1], wav_target_length),\n                        [self.sample_rate] * ref_wav[0].size(0),\n                        [None], [0.])\n                with self.autocast:\n                    gen_tokens = self.lm.generate(\n                        prompt_tokens, attributes,\n                        callback=callback, max_gen_len=max_gen_len, **self.generation_params)\n                if prompt_tokens is None:\n                    all_tokens.append(gen_tokens)\n                else:\n                    all_tokens.append(gen_tokens[:, :, prompt_tokens.shape[-1]:])\n                prompt_tokens = gen_tokens[:, :, stride_tokens:]\n                prompt_length = prompt_tokens.shape[-1]\n                current_gen_offset += stride_tokens\n\n            gen_tokens = torch.cat(all_tokens, dim=-1)\n        return gen_tokens\n",
            "Example": [
                "import torch\nfrom audiocraft.models import MusicGen\nfrom audiocraft.data.audio import audio_write\n\n# 加载预训练模型\nmodel = MusicGen.get_pretrained('facebook/musicgen-small')\n\n# 设置生成参数，这里生成1秒的音乐\nmodel.set_generation_params(duration=0.1)\n\n# 定义音乐描述文本\ndescriptions = ['A pop song']\n\n# 生成音乐\nwav = model.generate(descriptions)\n\n# 将生成的音乐保存为文件\nfor idx, one_wav in enumerate(wav):\n    # 保存为WAV文件，这里以生成的索引命名\n    audio_write(f'music_{idx}', one_wav.cpu(), model.sample_rate, strategy=\"loudness\", loudness_headroom_db=16)\n\nprint(\"音乐生成并保存成功！\")\n"
            ]
        }
    ]
}