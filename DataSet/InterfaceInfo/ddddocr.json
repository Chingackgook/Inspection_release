{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/ddddocr",
    "API_Calls": [
        {
            "Name": "OCREngine_predict_call",
            "Description": "class DdddOcr call ocr_engine.predict",
            "Code": "# coding=utf-8\n\"\"\"\n向后兼容性支持模块\n提供与原始DdddOcr类完全兼容的接口\n\"\"\"\n\nfrom typing import Union, List, Optional, Dict, Any, Tuple\nimport pathlib\nfrom PIL import Image\n\nfrom ..core.ocr_engine import OCREngine\nfrom ..core.detection_engine import DetectionEngine\nfrom ..core.slide_engine import SlideEngine\nfrom ..utils.exceptions import DDDDOCRError\nfrom ..utils.validators import validate_model_config\n\n\nclass DdddOcr:\n    \"\"\"\n    DDDDOCR主类 - 向后兼容版本\n    \n    这个类保持与原始DdddOcr类完全相同的接口，\n    但内部使用新的模块化架构实现\n    \"\"\"\n    \n    def __init__(self, ocr: bool = True, det: bool = False, old: bool = False, beta: bool = False,\n                 use_gpu: bool = False, device_id: int = 0, show_ad: bool = True, \n                 import_onnx_path: str = \"\", charsets_path: str = \"\"):\n        \"\"\"\n        初始化DDDDOCR\n        \n        Args:\n            ocr: 是否启用OCR功能\n            det: 是否启用目标检测功能\n            old: 是否使用旧版OCR模型\n            beta: 是否使用beta版OCR模型\n            use_gpu: 是否使用GPU\n            device_id: GPU设备ID\n            show_ad: 是否显示广告信息\n            import_onnx_path: 自定义ONNX模型路径\n            charsets_path: 自定义字符集路径\n        \"\"\"\n        # 显示广告信息（保持原有行为）\n        if show_ad:\n            print(\"欢迎使用ddddocr，本项目专注带动行业内卷，个人博客:wenanzhe.com\")\n            print(\"训练数据支持来源于:http://146.56.204.113:19199/preview\")\n            print(\"爬虫框架feapder可快速一键接入，快速开启爬虫之旅：https://github.com/Boris-code/feapder\")\n            print(\"谷歌reCaptcha验证码 / hCaptcha验证码 / funCaptcha验证码商业级识别接口：https://yescaptcha.com/i/NSwk7i\")\n        \n        # 兼容性处理：确保PIL有ANTIALIAS属性\n        if not hasattr(Image, 'ANTIALIAS'):\n            setattr(Image, 'ANTIALIAS', Image.LANCZOS)\n        \n        # 验证配置参数\n        validate_model_config(ocr, det, old, beta, use_gpu, device_id)\n        \n        # 保存配置\n        self.ocr_enabled = ocr\n        self.det_enabled = det\n        self.old = old\n        self.beta = beta\n        self.use_gpu = use_gpu\n        self.device_id = device_id\n        self.import_onnx_path = import_onnx_path\n        self.charsets_path = charsets_path\n        \n        # 初始化引擎\n        self.ocr_engine: Optional[OCREngine] = None\n        self.detection_engine: Optional[DetectionEngine] = None\n        self.slide_engine: Optional[SlideEngine] = None\n        \n        # 根据配置初始化相应的引擎\n        if det:\n            # 目标检测模式\n            self.det = True\n            self.detection_engine = DetectionEngine(use_gpu, device_id)\n        elif ocr or import_onnx_path:\n            # OCR模式\n            self.det = False\n            self.ocr_engine = OCREngine(\n                use_gpu=use_gpu,\n                device_id=device_id,\n                old=old,\n                beta=beta,\n                import_onnx_path=import_onnx_path,\n                charsets_path=charsets_path\n            )\n        else:\n            # 滑块模式\n            self.det = False\n            \n        # 滑块引擎总是可用\n        self.slide_engine = SlideEngine()\n    \n    def classification(self, img: Union[bytes, str, pathlib.PurePath, Image.Image], \n                      png_fix: bool = False, probability: bool = False,\n                      color_filter_colors: Optional[List[str]] = None,\n                      color_filter_custom_ranges: Optional[List[Tuple[Tuple[int, int, int], Tuple[int, int, int]]]] = None) -> Union[str, Dict[str, Any]]:\n        \"\"\"\n        OCR识别方法\n        \n        Args:\n            img: 图片数据（bytes、str、pathlib.PurePath或PIL.Image）\n            png_fix: 是否修复PNG透明背景问题\n            probability: 是否返回概率信息\n            color_filter_colors: 颜色过滤预设颜色列表，如 ['red', 'blue']\n            color_filter_custom_ranges: 自定义HSV颜色范围列表，如 [((0,50,50), (10,255,255))]\n        \n        Returns:\n            识别结果文本或包含概率信息的字典\n            \n        Raises:\n            DDDDOCRError: 当功能未启用或识别失败时\n        \"\"\"\n        if self.det:\n            raise DDDDOCRError(\"当前识别类型为目标检测\")\n        \n        if not self.ocr_engine:\n            raise DDDDOCRError(\"OCR功能未初始化\")\n        \n        return self.ocr_engine.predict(\n            image=img,\n            png_fix=png_fix,\n            probability=probability,\n            color_filter_colors=color_filter_colors,\n            color_filter_custom_ranges=color_filter_custom_ranges\n        )\n    \n    def detection(self, img: Union[bytes, str, pathlib.PurePath, Image.Image]) -> List[List[int]]:\n        \"\"\"\n        目标检测方法\n        \n        Args:\n            img: 图片数据\n            \n        Returns:\n            检测到的边界框列表\n            \n        Raises:\n            DDDDOCRError: 当功能未启用或检测失败时\n        \"\"\"\n        if not self.det:\n            raise DDDDOCRError(\"当前识别类型为OCR\")\n        \n        if not self.detection_engine:\n            raise DDDDOCRError(\"目标检测功能未初始化\")\n        \n        return self.detection_engine.predict(img)\n    \n    def slide_match(self, target_img: Union[bytes, str, pathlib.PurePath, Image.Image],\n                   background_img: Union[bytes, str, pathlib.PurePath, Image.Image],\n                   simple_target: bool = False) -> Dict[str, Any]:\n        \"\"\"\n        滑块匹配方法\n        \n        Args:\n            target_img: 滑块图片\n            background_img: 背景图片\n            simple_target: 是否为简单滑块\n            \n        Returns:\n            匹配结果字典\n            \n        Raises:\n            DDDDOCRError: 当匹配失败时\n        \"\"\"\n        if not self.slide_engine:\n            raise DDDDOCRError(\"滑块功能未初始化\")\n        \n        return self.slide_engine.slide_match(target_img, background_img, simple_target)\n    \n    def slide_comparison(self, target_img: Union[bytes, str, pathlib.PurePath, Image.Image],\n                        background_img: Union[bytes, str, pathlib.PurePath, Image.Image]) -> Dict[str, Any]:\n        \"\"\"\n        滑块比较方法\n        \n        Args:\n            target_img: 带坑位的图片\n            background_img: 完整背景图片\n            \n        Returns:\n            比较结果字典\n            \n        Raises:\n            DDDDOCRError: 当比较失败时\n        \"\"\"\n        if not self.slide_engine:\n            raise DDDDOCRError(\"滑块功能未初始化\")\n        \n        return self.slide_engine.slide_comparison(target_img, background_img)\n    \n    def set_ranges(self, charset_range: Union[int, str, List[str]]) -> None:\n        \"\"\"\n        设置字符集范围\n        \n        Args:\n            charset_range: 字符集范围参数\n            \n        Raises:\n            DDDDOCRError: 当OCR功能未启用时\n        \"\"\"\n        if self.det:\n            raise DDDDOCRError(\"目标检测模式不支持字符集设置\")\n        \n        if not self.ocr_engine:\n            raise DDDDOCRError(\"OCR功能未初始化\")\n        \n        self.ocr_engine.set_charset_range(charset_range)\n    \n    def get_charset(self) -> List[str]:\n        \"\"\"\n        获取字符集\n        \n        Returns:\n            字符集列表\n            \n        Raises:\n            DDDDOCRError: 当OCR功能未启用时\n        \"\"\"\n        if self.det:\n            raise DDDDOCRError(\"目标检测模式不支持字符集获取\")\n        \n        if not self.ocr_engine:\n            raise DDDDOCRError(\"OCR功能未初始化\")\n        \n        return self.ocr_engine.get_charset()\n    \n    def switch_device(self, use_gpu: bool, device_id: int = 0) -> None:\n        \"\"\"\n        切换计算设备\n        \n        Args:\n            use_gpu: 是否使用GPU\n            device_id: GPU设备ID\n        \"\"\"\n        self.use_gpu = use_gpu\n        self.device_id = device_id\n        \n        # 更新所有已初始化的引擎\n        if self.ocr_engine:\n            self.ocr_engine.switch_device(use_gpu, device_id)\n        \n        if self.detection_engine:\n            self.detection_engine.switch_device(use_gpu, device_id)\n    \n    def get_model_info(self) -> Dict[str, Any]:\n        \"\"\"\n        获取模型信息\n        \n        Returns:\n            模型信息字典\n        \"\"\"\n        info = {\n            'ocr_enabled': self.ocr_enabled,\n            'det_enabled': self.det_enabled,\n            'use_gpu': self.use_gpu,\n            'device_id': self.device_id\n        }\n        \n        if self.ocr_engine:\n            info['ocr_model'] = self.ocr_engine.get_model_info()\n        \n        if self.detection_engine:\n            info['detection_model'] = self.detection_engine.get_model_info()\n        \n        return info\n    \n    def cleanup(self) -> None:\n        \"\"\"清理所有资源\"\"\"\n        if self.ocr_engine:\n            self.ocr_engine.cleanup()\n        \n        if self.detection_engine:\n            self.detection_engine.cleanup()\n        \n        if self.slide_engine:\n            self.slide_engine.cleanup()\n    \n    def __del__(self):\n        \"\"\"析构函数\"\"\"\n        self.cleanup()\n    \n    def __repr__(self) -> str:\n        return f\"DdddOcr(ocr={self.ocr_enabled}, det={self.det_enabled}, use_gpu={self.use_gpu})\"\n",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/ddddocr/ddddocr/compat/legacy.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "OCREngine",
            "Description": "OCREngine_impl",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/ddddocr/ddddocr/core/ocr_engine.py",
            "Implementation": "# coding=utf-8\n\"\"\"\nOCR识别引擎\n提供文字识别功能\n\"\"\"\n\nfrom typing import Union, List, Optional, Dict, Any, Tuple\nimport numpy as np\nfrom PIL import Image\n\nfrom .base import BaseEngine\nfrom ..models.charset_manager import CharsetManager\nfrom ..preprocessing.color_filter import ColorFilter\nfrom ..preprocessing.image_processor import ImageProcessor\nfrom ..utils.image_io import load_image_from_input, png_rgba_black_preprocess\nfrom ..utils.exceptions import ModelLoadError, ImageProcessError\nfrom ..utils.validators import validate_image_input\n\n\nclass OCREngine(BaseEngine):\n    \"\"\"OCR识别引擎\"\"\"\n    \n    def __init__(self, use_gpu: bool = False, device_id: int = 0, \n                 old: bool = False, beta: bool = False,\n                 import_onnx_path: str = \"\", charsets_path: str = \"\"):\n        \"\"\"\n        初始化OCR引擎\n        \n        Args:\n            use_gpu: 是否使用GPU\n            device_id: GPU设备ID\n            old: 是否使用旧版模型\n            beta: 是否使用beta版模型\n            import_onnx_path: 自定义模型路径\n            charsets_path: 自定义字符集路径\n        \"\"\"\n        super().__init__(use_gpu, device_id)\n        \n        self.old = old\n        self.beta = beta\n        self.import_onnx_path = import_onnx_path\n        self.charsets_path = charsets_path\n        self.use_import_onnx = bool(import_onnx_path)\n        \n        # 字符集管理器\n        self.charset_manager = CharsetManager()\n        \n        # 模型配置\n        self.word = False\n        self.resize = []\n        self.channel = 1\n        \n        # 初始化引擎\n        self.initialize()\n    \n    def initialize(self, **kwargs) -> None:\n        \"\"\"\n        初始化OCR引擎\n        \n        Raises:\n            ModelLoadError: 当初始化失败时\n        \"\"\"\n        try:\n            if self.use_import_onnx:\n                # 加载自定义模型\n                self.session, charset_info = self.model_loader.load_custom_model(\n                    self.import_onnx_path, self.charsets_path\n                )\n                \n                # 设置模型配置\n                self.charset_manager.charset = charset_info['charset']\n\n                # 初始化有效字符索引（使用完整字符集）\n                self.charset_manager._update_valid_indices()\n\n                self.word = charset_info['word']\n                self.resize = charset_info['image']\n                self.channel = charset_info['channel']\n            else:\n                # 加载默认模型\n                self.session = self.model_loader.load_ocr_model(self.old, self.beta)\n                \n                # 加载默认字符集\n                self.charset_manager.load_default_charset(self.old, self.beta)\n\n                # 初始化有效字符索引（使用完整字符集）\n                self.charset_manager._update_valid_indices()\n\n                # 设置默认配置\n                self.word = False\n                self.resize = [64, 64]  # 默认尺寸\n                self.channel = 1\n            \n            self.is_initialized = True\n            \n        except Exception as e:\n            raise ModelLoadError(f\"OCR引擎初始化失败: {str(e)}\") from e\n    \n    def predict(self, image: Union[bytes, str, Image.Image], \n                png_fix: bool = False, probability: bool = False,\n                color_filter_colors: Optional[List[str]] = None,\n                color_filter_custom_ranges: Optional[List[Tuple[Tuple[int, int, int], Tuple[int, int, int]]]] = None,\n                charset_range: Optional[Union[int, str, List[str]]] = None) -> Union[str, Dict[str, Any]]:\n        \"\"\"\n        执行OCR识别\n        \n        Args:\n            image: 输入图像\n            png_fix: 是否修复PNG透明背景\n            probability: 是否返回概率信息\n            color_filter_colors: 颜色过滤预设颜色列表\n            color_filter_custom_ranges: 自定义HSV颜色范围列表\n            charset_range: 字符集范围限制\n            \n        Returns:\n            识别结果文本或包含概率信息的字典\n            \n        Raises:\n            ImageProcessError: 当图像处理失败时\n            ModelLoadError: 当模型未初始化时\n        \"\"\"\n        if not self.is_ready():\n            raise ModelLoadError(\"OCR引擎未初始化\")\n        \n        # 验证输入\n        validate_image_input(image)\n        \n        try:\n            # 加载图像\n            pil_image = load_image_from_input(image)\n            \n            # 应用颜色过滤\n            if color_filter_colors or color_filter_custom_ranges:\n                try:\n                    color_filter = ColorFilter(colors=color_filter_colors, \n                                             custom_ranges=color_filter_custom_ranges)\n                    pil_image = color_filter.filter_image(pil_image)\n                except Exception as e:\n                    print(f\"颜色过滤警告: {str(e)}，将跳过颜色过滤步骤\")\n            \n            # 设置字符集范围\n            if charset_range is not None:\n                self.charset_manager.set_ranges(charset_range)\n            else:\n                # 确保在没有设置字符集范围时，有效索引被正确初始化\n                self.charset_manager._update_valid_indices()\n            \n            # 预处理图像\n            processed_image = self._preprocess_image(pil_image, png_fix)\n            \n            # 执行推理\n            result = self._inference(processed_image, probability)\n            \n            return result\n            \n        except Exception as e:\n            raise ImageProcessError(f\"OCR识别失败: {str(e)}\") from e\n    \n    def _preprocess_image(self, image: Image.Image, png_fix: bool) -> np.ndarray:\n        \"\"\"\n        预处理图像\n        \n        Args:\n            image: 输入图像\n            png_fix: 是否修复PNG透明背景\n            \n        Returns:\n            预处理后的numpy数组\n        \"\"\"\n        try:\n            # 处理PNG透明背景\n            if png_fix and image.mode == 'RGBA':\n                image = png_rgba_black_preprocess(image)\n            \n            # 调整图像尺寸\n            if not self.use_import_onnx:\n                # 默认模型的预处理\n                target_height = 64\n                target_width = int(image.size[0] * (target_height / image.size[1]))\n                image = ImageProcessor.resize_image(image, (target_width, target_height))\n                image = ImageProcessor.convert_to_grayscale(image)\n            else:\n                # 自定义模型的预处理\n                if self.resize[0] == -1:\n                    if self.word:\n                        image = ImageProcessor.resize_image(image, (self.resize[1], self.resize[1]))\n                    else:\n                        target_height = self.resize[1]\n                        target_width = int(image.size[0] * (target_height / image.size[1]))\n                        image = ImageProcessor.resize_image(image, (target_width, target_height))\n                else:\n                    image = ImageProcessor.resize_image(image, (self.resize[0], self.resize[1]))\n                \n                # 根据通道数转换\n                if self.channel == 1:\n                    image = ImageProcessor.convert_to_grayscale(image)\n            \n            # 转换为numpy数组并标准化\n            img_array = np.array(image).astype(np.float32)\n            \n            # 标准化到[0,1]\n            img_array = img_array / 255.0\n            \n            # 调整维度\n            if len(img_array.shape) == 2:\n                img_array = np.expand_dims(img_array, axis=0)  # 添加通道维度\n            elif len(img_array.shape) == 3:\n                img_array = img_array.transpose(2, 0, 1)  # HWC -> CHW\n            \n            img_array = np.expand_dims(img_array, axis=0)  # 添加batch维度\n            \n            return img_array\n            \n        except Exception as e:\n            raise ImageProcessError(f\"图像预处理失败: {str(e)}\") from e\n    \n    def _inference(self, image_array: np.ndarray, probability: bool) -> Union[str, Dict[str, Any]]:\n        \"\"\"\n        执行模型推理\n        \n        Args:\n            image_array: 预处理后的图像数组\n            probability: 是否返回概率信息\n            \n        Returns:\n            识别结果\n        \"\"\"\n        try:\n            # 获取输入名称\n            input_name = self.session.get_inputs()[0].name\n            \n            # 执行推理\n            outputs = self.session.run(None, {input_name: image_array})\n            \n            # 处理输出\n            if probability:\n                return self._process_probability_output(outputs[0])\n            else:\n                return self._process_text_output(outputs[0])\n                \n        except Exception as e:\n            raise ModelLoadError(f\"模型推理失败: {str(e)}\") from e\n    \n    def _process_text_output(self, output: np.ndarray) -> str:\n        \"\"\"\n        处理文本输出\n        \n        Args:\n            output: 模型输出\n            \n        Returns:\n            识别的文本\n        \"\"\"\n        try:\n            # 获取预测结果\n            if len(output.shape) == 3:\n                # 序列输出 (sequence_length, batch_size, num_classes) 或 (batch_size, sequence_length, num_classes)\n                # 需要判断哪个维度是batch_size=1\n                if output.shape[1] == 1:\n                    # 形状为 (sequence_length, 1, num_classes)\n                    predicted_indices = np.argmax(output[:, 0, :], axis=1)\n                elif output.shape[0] == 1:\n                    # 形状为 (1, sequence_length, num_classes)\n                    predicted_indices = np.argmax(output[0, :, :], axis=1)\n                else:\n                    # 默认取第一个batch\n                    predicted_indices = np.argmax(output[0, :, :], axis=1)\n            else:\n                # 单字符输出或2D序列输出\n                predicted_indices = np.argmax(output, axis=-1)\n                # 确保结果是数组形式，即使是单个值\n                if predicted_indices.ndim == 0:\n                    predicted_indices = np.array([predicted_indices])\n            \n            # 正确的CTC解码：在索引级别进行去重\n            charset = self.charset_manager.get_charset()\n            valid_indices = self.charset_manager.get_valid_indices()\n\n            # 步骤1：CTC解码 - 在索引级别去除连续重复\n            decoded_indices = self._ctc_decode_indices(predicted_indices)\n\n            # 步骤2：转换为字符并应用字符集范围限制\n            result_chars = []\n            for idx in decoded_indices:\n                # 检查字符集范围限制\n                if valid_indices and idx not in valid_indices:\n                    continue\n\n                # 检查索引有效性并转换为字符\n                if 0 <= idx < len(charset):\n                    char = charset[idx]\n                    # 注意：这里不跳过空字符，因为CTC解码已经处理了blank\n                    result_chars.append(char)\n\n            return ''.join(result_chars)\n            \n        except Exception as e:\n            raise ModelLoadError(f\"文本输出处理失败: {str(e)}\") from e\n\n    def _ctc_decode_indices(self, predicted_indices: np.ndarray) -> List[int]:\n        \"\"\"\n        CTC解码：在索引级别去除连续重复和blank字符\n\n        Args:\n            predicted_indices: 预测的索引数组\n\n        Returns:\n            解码后的索引列表\n        \"\"\"\n        if len(predicted_indices) == 0:\n            return []\n\n        decoded_indices = []\n        prev_idx = None\n\n        for idx in predicted_indices:\n            # 转换为Python int类型以确保一致性\n            idx = int(idx)\n\n            # CTC解码规则：\n            # 1. 跳过连续重复的索引\n            # 2. 跳过blank字符（索引0，对应空字符）\n            if idx != prev_idx:  # 不是连续重复\n                if idx != 0:  # 不是blank字符（假设索引0是blank）\n                    decoded_indices.append(idx)\n\n            prev_idx = idx\n\n        return decoded_indices\n\n    def _process_probability_output(self, output: np.ndarray) -> Dict[str, Any]:\n        \"\"\"\n        处理概率输出\n        \n        Args:\n            output: 模型输出\n            \n        Returns:\n            包含概率信息的字典\n        \"\"\"\n        try:\n            # 应用softmax\n            if len(output.shape) == 3:\n                probabilities = self._softmax(output, axis=2)\n            else:\n                probabilities = self._softmax(output, axis=1)\n            \n            # 获取文本结果\n            text_result = self._process_text_output(output)\n            \n            # 构建概率信息\n            charset = self.charset_manager.get_charset()\n            prob_info = {\n                'text': text_result,\n                'probabilities': probabilities.tolist(),\n                'charset': charset,\n                'confidence': float(np.mean(np.max(probabilities, axis=-1)))\n            }\n            \n            return prob_info\n            \n        except Exception as e:\n            raise ModelLoadError(f\"概率输出处理失败: {str(e)}\") from e\n    \n    def _softmax(self, x: np.ndarray, axis: int = -1) -> np.ndarray:\n        \"\"\"\n        计算softmax\n        \n        Args:\n            x: 输入数组\n            axis: 计算轴\n            \n        Returns:\n            softmax结果\n        \"\"\"\n        exp_x = np.exp(x - np.max(x, axis=axis, keepdims=True))\n        return exp_x / np.sum(exp_x, axis=axis, keepdims=True)\n    \n    def set_charset_range(self, charset_range: Union[int, str, List[str]]) -> None:\n        \"\"\"\n        设置字符集范围\n        \n        Args:\n            charset_range: 字符集范围参数\n        \"\"\"\n        self.charset_manager.set_ranges(charset_range)\n    \n    def get_charset(self) -> List[str]:\n        \"\"\"\n        获取字符集\n        \n        Returns:\n            字符集列表\n        \"\"\"\n        return self.charset_manager.get_charset()\n    \n    def _reload_model(self) -> None:\n        \"\"\"重新加载模型\"\"\"\n        self.initialize()\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}