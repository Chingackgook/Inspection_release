{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/point-e",
    "API_Calls": [
        {
            "Name": "call_PointCloudSampler",
            "Description": "PointCloudSampler",
            "Code": "import torch\nfrom tqdm.auto import tqdm\n\nfrom point_e.diffusion.configs import DIFFUSION_CONFIGS, diffusion_from_config\nfrom point_e.diffusion.sampler import PointCloudSampler\nfrom point_e.models.download import load_checkpoint\nfrom point_e.models.configs import MODEL_CONFIGS, model_from_config\nfrom point_e.util.plotting import plot_point_cloud\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nprint('creating base model...')\nbase_name = 'base40M-textvec'\nbase_model = model_from_config(MODEL_CONFIGS[base_name], device)\nbase_model.eval()\nbase_diffusion = diffusion_from_config(DIFFUSION_CONFIGS[base_name])\n\nprint('creating upsample model...')\nupsampler_model = model_from_config(MODEL_CONFIGS['upsample'], device)\nupsampler_model.eval()\nupsampler_diffusion = diffusion_from_config(DIFFUSION_CONFIGS['upsample'])\n\nprint('downloading base checkpoint...')\nbase_model.load_state_dict(load_checkpoint(base_name, device))\n\nprint('downloading upsampler checkpoint...')\nupsampler_model.load_state_dict(load_checkpoint('upsample', device))\n\n\nsampler = PointCloudSampler(\n    device=device,\n    models=[base_model, upsampler_model],\n    diffusions=[base_diffusion, upsampler_diffusion],\n    num_points=[1024, 4096 - 1024],\n    aux_channels=['R', 'G', 'B'],\n    guidance_scale=[3.0, 0.0],\n    model_kwargs_key_filter=('texts', ''), # Do not condition the upsampler at all\n)\n\n# Set a prompt to condition on.\nprompt = 'a red motorcycle'\n\n# Produce a sample from the model.\nsamples = None\nfor x in tqdm(sampler.sample_batch_progressive(batch_size=1, model_kwargs=dict(texts=[prompt]))):\n    samples = x\n\npc = sampler.output_to_point_clouds(samples)[0]\nfig = plot_point_cloud(pc, grid_size=3, fixed_bounds=((-0.75, -0.75, -0.75),(0.75, 0.75, 0.75)))",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/point-e/point_e/examples/text2pointcloud.ipynb"
        }
    ],
    "API_Implementations": [
        {
            "Name": "PointCloudSampler",
            "Description": "PointCloudSampler",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/point-e/point_e/diffusion/sampler.py",
            "Implementation": "\"\"\"\nHelpers for sampling from a single- or multi-stage point cloud diffusion model.\n\"\"\"\n\nfrom typing import Any, Callable, Dict, Iterator, List, Sequence, Tuple\n\nimport torch\nimport torch.nn as nn\n\nfrom point_e.util.point_cloud import PointCloud\n\nfrom .gaussian_diffusion import GaussianDiffusion\nfrom .k_diffusion import karras_sample_progressive\n\n\nclass PointCloudSampler:\n    \"\"\"\n    A wrapper around a model or stack of models that produces conditional or\n    unconditional sample tensors.\n\n    By default, this will load models and configs from files.\n    If you want to modify the sampler arguments of an existing sampler, call\n    with_options() or with_args().\n    \"\"\"\n\n    def __init__(\n        self,\n        device: torch.device,\n        models: Sequence[nn.Module],\n        diffusions: Sequence[GaussianDiffusion],\n        num_points: Sequence[int],\n        aux_channels: Sequence[str],\n        model_kwargs_key_filter: Sequence[str] = (\"*\",),\n        guidance_scale: Sequence[float] = (3.0, 3.0),\n        clip_denoised: bool = True,\n        use_karras: Sequence[bool] = (True, True),\n        karras_steps: Sequence[int] = (64, 64),\n        sigma_min: Sequence[float] = (1e-3, 1e-3),\n        sigma_max: Sequence[float] = (120, 160),\n        s_churn: Sequence[float] = (3, 0),\n    ):\n        n = len(models)\n        assert n > 0\n\n        if n > 1:\n            if len(guidance_scale) == 1:\n                # Don't guide the upsamplers by default.\n                guidance_scale = list(guidance_scale) + [1.0] * (n - 1)\n            if len(use_karras) == 1:\n                use_karras = use_karras * n\n            if len(karras_steps) == 1:\n                karras_steps = karras_steps * n\n            if len(sigma_min) == 1:\n                sigma_min = sigma_min * n\n            if len(sigma_max) == 1:\n                sigma_max = sigma_max * n\n            if len(s_churn) == 1:\n                s_churn = s_churn * n\n            if len(model_kwargs_key_filter) == 1:\n                model_kwargs_key_filter = model_kwargs_key_filter * n\n        if len(model_kwargs_key_filter) == 0:\n            model_kwargs_key_filter = [\"*\"] * n\n        assert len(guidance_scale) == n\n        assert len(use_karras) == n\n        assert len(karras_steps) == n\n        assert len(sigma_min) == n\n        assert len(sigma_max) == n\n        assert len(s_churn) == n\n        assert len(model_kwargs_key_filter) == n\n\n        self.device = device\n        self.num_points = num_points\n        self.aux_channels = aux_channels\n        self.model_kwargs_key_filter = model_kwargs_key_filter\n        self.guidance_scale = guidance_scale\n        self.clip_denoised = clip_denoised\n        self.use_karras = use_karras\n        self.karras_steps = karras_steps\n        self.sigma_min = sigma_min\n        self.sigma_max = sigma_max\n        self.s_churn = s_churn\n\n        self.models = models\n        self.diffusions = diffusions\n\n    @property\n    def num_stages(self) -> int:\n        return len(self.models)\n\n    def sample_batch(self, batch_size: int, model_kwargs: Dict[str, Any]) -> torch.Tensor:\n        samples = None\n        for x in self.sample_batch_progressive(batch_size, model_kwargs):\n            samples = x\n        return samples\n\n    def sample_batch_progressive(\n        self, batch_size: int, model_kwargs: Dict[str, Any]\n    ) -> Iterator[torch.Tensor]:\n        samples = None\n        for (\n            model,\n            diffusion,\n            stage_num_points,\n            stage_guidance_scale,\n            stage_use_karras,\n            stage_karras_steps,\n            stage_sigma_min,\n            stage_sigma_max,\n            stage_s_churn,\n            stage_key_filter,\n        ) in zip(\n            self.models,\n            self.diffusions,\n            self.num_points,\n            self.guidance_scale,\n            self.use_karras,\n            self.karras_steps,\n            self.sigma_min,\n            self.sigma_max,\n            self.s_churn,\n            self.model_kwargs_key_filter,\n        ):\n            stage_model_kwargs = model_kwargs.copy()\n            if stage_key_filter != \"*\":\n                use_keys = set(stage_key_filter.split(\",\"))\n                stage_model_kwargs = {k: v for k, v in stage_model_kwargs.items() if k in use_keys}\n            if samples is not None:\n                stage_model_kwargs[\"low_res\"] = samples\n            if hasattr(model, \"cached_model_kwargs\"):\n                stage_model_kwargs = model.cached_model_kwargs(batch_size, stage_model_kwargs)\n            sample_shape = (batch_size, 3 + len(self.aux_channels), stage_num_points)\n\n            if stage_guidance_scale != 1 and stage_guidance_scale != 0:\n                for k, v in stage_model_kwargs.copy().items():\n                    stage_model_kwargs[k] = torch.cat([v, torch.zeros_like(v)], dim=0)\n\n            if stage_use_karras:\n                samples_it = karras_sample_progressive(\n                    diffusion=diffusion,\n                    model=model,\n                    shape=sample_shape,\n                    steps=stage_karras_steps,\n                    clip_denoised=self.clip_denoised,\n                    model_kwargs=stage_model_kwargs,\n                    device=self.device,\n                    sigma_min=stage_sigma_min,\n                    sigma_max=stage_sigma_max,\n                    s_churn=stage_s_churn,\n                    guidance_scale=stage_guidance_scale,\n                )\n            else:\n                internal_batch_size = batch_size\n                if stage_guidance_scale:\n                    model = self._uncond_guide_model(model, stage_guidance_scale)\n                    internal_batch_size *= 2\n                samples_it = diffusion.p_sample_loop_progressive(\n                    model,\n                    shape=(internal_batch_size, *sample_shape[1:]),\n                    model_kwargs=stage_model_kwargs,\n                    device=self.device,\n                    clip_denoised=self.clip_denoised,\n                )\n            for x in samples_it:\n                samples = x[\"pred_xstart\"][:batch_size]\n                if \"low_res\" in stage_model_kwargs:\n                    samples = torch.cat(\n                        [stage_model_kwargs[\"low_res\"][: len(samples)], samples], dim=-1\n                    )\n                yield samples\n\n    @classmethod\n    def combine(cls, *samplers: \"PointCloudSampler\") -> \"PointCloudSampler\":\n        assert all(x.device == samplers[0].device for x in samplers[1:])\n        assert all(x.aux_channels == samplers[0].aux_channels for x in samplers[1:])\n        assert all(x.clip_denoised == samplers[0].clip_denoised for x in samplers[1:])\n        return cls(\n            device=samplers[0].device,\n            models=[x for y in samplers for x in y.models],\n            diffusions=[x for y in samplers for x in y.diffusions],\n            num_points=[x for y in samplers for x in y.num_points],\n            aux_channels=samplers[0].aux_channels,\n            model_kwargs_key_filter=[x for y in samplers for x in y.model_kwargs_key_filter],\n            guidance_scale=[x for y in samplers for x in y.guidance_scale],\n            clip_denoised=samplers[0].clip_denoised,\n            use_karras=[x for y in samplers for x in y.use_karras],\n            karras_steps=[x for y in samplers for x in y.karras_steps],\n            sigma_min=[x for y in samplers for x in y.sigma_min],\n            sigma_max=[x for y in samplers for x in y.sigma_max],\n            s_churn=[x for y in samplers for x in y.s_churn],\n        )\n\n    def _uncond_guide_model(\n        self, model: Callable[..., torch.Tensor], scale: float\n    ) -> Callable[..., torch.Tensor]:\n        def model_fn(x_t, ts, **kwargs):\n            half = x_t[: len(x_t) // 2]\n            combined = torch.cat([half, half], dim=0)\n            model_out = model(combined, ts, **kwargs)\n            eps, rest = model_out[:, :3], model_out[:, 3:]\n            cond_eps, uncond_eps = torch.chunk(eps, 2, dim=0)\n            half_eps = uncond_eps + scale * (cond_eps - uncond_eps)\n            eps = torch.cat([half_eps, half_eps], dim=0)\n            return torch.cat([eps, rest], dim=1)\n\n        return model_fn\n\n    def split_model_output(\n        self,\n        output: torch.Tensor,\n        rescale_colors: bool = False,\n    ) -> Tuple[torch.Tensor, Dict[str, torch.Tensor]]:\n        assert (\n            len(self.aux_channels) + 3 == output.shape[1]\n        ), \"there must be three spatial channels before aux\"\n        pos, joined_aux = output[:, :3], output[:, 3:]\n\n        aux = {}\n        for i, name in enumerate(self.aux_channels):\n            v = joined_aux[:, i]\n            if name in {\"R\", \"G\", \"B\", \"A\"}:\n                v = v.clamp(0, 255).round()\n                if rescale_colors:\n                    v = v / 255.0\n            aux[name] = v\n        return pos, aux\n\n    def output_to_point_clouds(self, output: torch.Tensor) -> List[PointCloud]:\n        res = []\n        for sample in output:\n            xyz, aux = self.split_model_output(sample[None], rescale_colors=True)\n            res.append(\n                PointCloud(\n                    coords=xyz[0].t().cpu().numpy(),\n                    channels={k: v[0].cpu().numpy() for k, v in aux.items()},\n                )\n            )\n        return res\n\n    def with_options(\n        self,\n        guidance_scale: float,\n        clip_denoised: bool,\n        use_karras: Sequence[bool] = (True, True),\n        karras_steps: Sequence[int] = (64, 64),\n        sigma_min: Sequence[float] = (1e-3, 1e-3),\n        sigma_max: Sequence[float] = (120, 160),\n        s_churn: Sequence[float] = (3, 0),\n    ) -> \"PointCloudSampler\":\n        return PointCloudSampler(\n            device=self.device,\n            models=self.models,\n            diffusions=self.diffusions,\n            num_points=self.num_points,\n            aux_channels=self.aux_channels,\n            model_kwargs_key_filter=self.model_kwargs_key_filter,\n            guidance_scale=guidance_scale,\n            clip_denoised=clip_denoised,\n            use_karras=use_karras,\n            karras_steps=karras_steps,\n            sigma_min=sigma_min,\n            sigma_max=sigma_max,\n            s_churn=s_churn,\n        )\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}