{
    "Project_Root": "/mnt/autor_name/haoTingDeWenJianJia/marker",
    "API_Calls": [
        {
            "Name": "PdfConverter_call",
            "Description": "call PdfConverter to convert PDF files into various formats like Markdown, JSON, and HTML. It uses a model dictionary for processing and supports multiple processors and builders for document structure and rendering.",
            "Code": "import time\nimport torch\n\nimport click\nimport pypdfium2 as pdfium\nfrom tqdm import tqdm\n\nfrom marker.converters.pdf import PdfConverter\nfrom marker.models import create_model_dict\n\n\n@click.command(help=\"Benchmark PDF to MD conversion throughput.\")\n@click.argument(\"pdf_path\", type=str)\ndef main(pdf_path):\n    print(f\"Converting {pdf_path} to markdown...\")\n    pdf = pdfium.PdfDocument(pdf_path)\n    page_count = len(pdf)\n    pdf.close()\n    model_dict = create_model_dict()\n    torch.cuda.reset_peak_memory_stats()\n\n    times = []\n    for i in tqdm(range(10), desc=\"Benchmarking\"):\n        block_converter = PdfConverter(\n            artifact_dict=model_dict,\n            config={\"disable_tqdm\": True}\n        )\n        start = time.time()\n        block_converter(pdf_path)\n        total = time.time() - start\n        times.append(total)\n\n    max_gpu_vram = torch.cuda.max_memory_allocated() / 1024 ** 3\n\n    print(f\"Converted {page_count} pages in {sum(times)/len(times):.2f} seconds.\")\n    print(f\"Max GPU VRAM: {max_gpu_vram:.2f} GB\")\n\n\nif __name__ == \"__main__\":\n    main()",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/marker/benchmarks/throughput/main.py"
        }
    ],
    "API_Implementations": [
        {
            "Name": "PdfConverter",
            "Description": "This file defines a PdfConverter class for processing PDF files into formats like Markdown, JSON, and HTML using various processors and builders.",
            "Path": "/mnt/autor_name/haoTingDeWenJianJia/marker/marker/converters/pdf.py",
            "Implementation": "import os\nos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"  # disables a tokenizers warning\n\nfrom collections import defaultdict\nfrom typing import Annotated, Any, Dict, List, Optional, Type, Tuple\n\nfrom marker.processors import BaseProcessor\nfrom marker.processors.llm.llm_table_merge import LLMTableMergeProcessor\nfrom marker.providers.registry import provider_from_filepath\nfrom marker.builders.document import DocumentBuilder\nfrom marker.builders.layout import LayoutBuilder\nfrom marker.builders.llm_layout import LLMLayoutBuilder\nfrom marker.builders.line import LineBuilder\nfrom marker.builders.ocr import OcrBuilder\nfrom marker.builders.structure import StructureBuilder\nfrom marker.converters import BaseConverter\nfrom marker.processors.blockquote import BlockquoteProcessor\nfrom marker.processors.code import CodeProcessor\nfrom marker.processors.debug import DebugProcessor\nfrom marker.processors.document_toc import DocumentTOCProcessor\nfrom marker.processors.equation import EquationProcessor\nfrom marker.processors.footnote import FootnoteProcessor\nfrom marker.processors.ignoretext import IgnoreTextProcessor\nfrom marker.processors.line_numbers import LineNumbersProcessor\nfrom marker.processors.list import ListProcessor\nfrom marker.processors.llm.llm_complex import LLMComplexRegionProcessor\nfrom marker.processors.llm.llm_form import LLMFormProcessor\nfrom marker.processors.llm.llm_image_description import LLMImageDescriptionProcessor\nfrom marker.processors.llm.llm_table import LLMTableProcessor\nfrom marker.processors.llm.llm_inlinemath import LLMInlineMathLinesProcessor\nfrom marker.processors.page_header import PageHeaderProcessor\nfrom marker.processors.reference import ReferenceProcessor\nfrom marker.processors.sectionheader import SectionHeaderProcessor\nfrom marker.processors.table import TableProcessor\nfrom marker.processors.text import TextProcessor\nfrom marker.processors.llm.llm_equation import LLMEquationProcessor\nfrom marker.renderers.markdown import MarkdownRenderer\nfrom marker.schema import BlockTypes\nfrom marker.schema.blocks import Block\nfrom marker.schema.registry import register_block_class\nfrom marker.util import strings_to_classes\nfrom marker.processors.llm.llm_handwriting import LLMHandwritingProcessor\nfrom marker.processors.order import OrderProcessor\nfrom marker.services.gemini import GoogleGeminiService\nfrom marker.processors.line_merge import LineMergeProcessor\nfrom marker.processors.llm.llm_mathblock import LLMMathBlockProcessor\n\n\nclass PdfConverter(BaseConverter):\n    \"\"\"\n    A converter for processing and rendering PDF files into Markdown, JSON, HTML and other formats.\n    \"\"\"\n    override_map: Annotated[\n        Dict[BlockTypes, Type[Block]],\n        \"A mapping to override the default block classes for specific block types.\",\n        \"The keys are `BlockTypes` enum values, representing the types of blocks,\",\n        \"and the values are corresponding `Block` class implementations to use\",\n        \"instead of the defaults.\"\n    ] = defaultdict()\n    use_llm: Annotated[\n        bool,\n        \"Enable higher quality processing with LLMs.\",\n    ] = False\n    default_processors: Tuple[BaseProcessor, ...] = (\n        OrderProcessor,\n        LineMergeProcessor,\n        BlockquoteProcessor,\n        CodeProcessor,\n        DocumentTOCProcessor,\n        EquationProcessor,\n        FootnoteProcessor,\n        IgnoreTextProcessor,\n        LineNumbersProcessor,\n        ListProcessor,\n        PageHeaderProcessor,\n        SectionHeaderProcessor,\n        TableProcessor,\n        LLMTableProcessor,\n        LLMTableMergeProcessor,\n        LLMFormProcessor,\n        TextProcessor,\n        LLMInlineMathLinesProcessor,\n        LLMComplexRegionProcessor,\n        LLMImageDescriptionProcessor,\n        LLMEquationProcessor,\n        LLMHandwritingProcessor,\n        LLMMathBlockProcessor,\n        ReferenceProcessor,\n        DebugProcessor,\n    )\n\n    def __init__(\n        self,\n        artifact_dict: Dict[str, Any],\n        processor_list: Optional[List[str]] = None,\n        renderer: str | None = None,\n        llm_service: str | None = None,\n        config=None\n    ):\n        super().__init__(config)\n\n        if config is None:\n            config = {}\n\n        for block_type, override_block_type in self.override_map.items():\n            register_block_class(block_type, override_block_type)\n\n        if processor_list:\n            processor_list = strings_to_classes(processor_list)\n        else:\n            processor_list = self.default_processors\n\n        if renderer:\n            renderer = strings_to_classes([renderer])[0]\n        else:\n            renderer = MarkdownRenderer\n\n        if llm_service:\n            llm_service_cls = strings_to_classes([llm_service])[0]\n            llm_service = self.resolve_dependencies(llm_service_cls)\n        elif config.get(\"use_llm\", False):\n            llm_service = self.resolve_dependencies(GoogleGeminiService)\n\n        # Inject llm service into artifact_dict so it can be picked up by processors, etc.\n        artifact_dict[\"llm_service\"] = llm_service\n        self.llm_service = llm_service\n\n        self.artifact_dict = artifact_dict\n        self.renderer = renderer\n\n        processor_list = self.initialize_processors(processor_list)\n        self.processor_list = processor_list\n\n        self.layout_builder_class = LayoutBuilder\n        if self.use_llm:\n            self.layout_builder_class = LLMLayoutBuilder\n\n    def build_document(self, filepath: str):\n        provider_cls = provider_from_filepath(filepath)\n        layout_builder = self.resolve_dependencies(self.layout_builder_class)\n        line_builder = self.resolve_dependencies(LineBuilder)\n        ocr_builder = self.resolve_dependencies(OcrBuilder)\n        provider = provider_cls(filepath, self.config)\n        document = DocumentBuilder(self.config)(provider, layout_builder, line_builder, ocr_builder)\n        structure_builder_cls = self.resolve_dependencies(StructureBuilder)\n        structure_builder_cls(document)\n\n        for processor in self.processor_list:\n            processor(document)\n\n        return document\n\n    def __call__(self, filepath: str):\n        document = self.build_document(filepath)\n        renderer = self.resolve_dependencies(self.renderer)\n        return renderer(document)\n",
            "Examples": [
                "\n"
            ]
        }
    ]
}